<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EnemyBlock1 - by Alon S.</title>
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXKSQPZ851"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-BXKSQPZ851'); // <-- âš ï¸ REPLACE WITH YOUR MEASUREMENT ID
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        #welcomeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .welcome-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: welcomeFadeIn 1s ease-out;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .welcome-content {
                padding: 20px;
                margin: 10px;
                border-radius: 15px;
            }
            .welcome-content h1 {
                font-size: 32px !important;
            }
            .subtitle {
                font-size: 16px !important;
            }
            .game-instructions {
                padding: 15px !important;
                margin: 20px 0 !important;
            }
            .game-instructions h3 {
                font-size: 20px !important;
            }
            .game-instructions h4 {
                font-size: 16px !important;
            }
            .game-instructions p {
                font-size: 14px !important;
                margin: 8px 0 !important;
            }
            .start-btn {
                font-size: 20px !important;
                padding: 12px 30px !important;
            }
        }
        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .welcome-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            animation: iconFloat 3s ease-in-out infinite;
        }
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .welcome-content h1 {
            font-size: 48px;
            color: #333;
            margin: 20px 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        .game-instructions {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 30px 0;
            text-align: right;
            direction: rtl;
        }
        .game-instructions p {
            margin: 10px 0;
            font-size: 16px;
            color: #444;
        }
        .start-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(102, 126, 234, 0.4);
        }
        .start-btn:active {
            transform: translateY(-1px);
        }
        canvas {
            display: block;
            background: #000;
        }
        .hearts {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: red;
        }
        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            border-radius: 10px;
        }
        #shop button {
            margin: 5px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 200px;
        }
        #shop button:hover {
            background-color: #367c39;
        }
        #shop h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }
        #victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 15;
            border-radius: 15px;
            border: 3px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        #victory h1 {
            margin-bottom: 20px;
            font-size: 48px;
            color: gold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px gold;
            }
            to {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px gold, 0 0 30px gold;
            }
        }
        #victory p {
            margin-bottom: 25px;
            font-size: 20px;
            text-align: center;
        }
        #victory button {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        #victory button:hover {
            background-color: #367c39;
            transform: scale(1.05);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 15;
            border-radius: 15px;
            border: 3px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }
        #gameOver h1 {
            margin-bottom: 20px;
            font-size: 48px;
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: gameOverGlow 2s ease-in-out infinite alternate;
        }
        @keyframes gameOverGlow {
            from {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px #ff4444;
            }
            to {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px #ff4444, 0 0 30px #ff4444;
            }
        }
        #gameOverStats {
            margin-bottom: 25px;
            text-align: center;
        }
        #gameOverStats p {
            margin: 10px 0;
            font-size: 18px;
        }
        #gameOverStats span {
            color: #ffdd44;
            font-weight: bold;
        }
        #gameOver button {
            padding: 15px 30px;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        #gameOver button:hover {
            background-color: #cc3333;
            transform: scale(1.05);
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
        }

        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 30px;
            pointer-events: none;
        }

        .control-cluster {
            pointer-events: auto;
        }
        
        .dpad {
            display: grid;
            grid-template-areas: ". up ." "left . right" ". down .";
            gap: 15px;
        }

        #up { grid-area: up; }
        #down { grid-area: down; }
        #left { grid-area: left; }
        #right { grid-area: right; }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #controls button {
            width: 70px;
            height: 70px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            color: white;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
        }

        #controls button:active {
            background: rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="welcomeScreen">
        <div class="welcome-content">
            <img src="favicon.png" alt="Game Icon" class="welcome-icon">
            <h1>EnemyBlock1</h1>
            <p class="subtitle">by Alon S.</p>
            <div class="game-instructions">
                <h3 style="margin-top: 0; color: #333;">ğŸ® ××™×š ×œ×©×—×§</h3>
                
                <div style="margin: 15px 0;">
                    <h4 style="color: #4CAF50; margin: 10px 0;">âŒ¨ï¸ ××§×œ×“×ª:</h4>
                    <p>ğŸƒ ×ª× ×•×¢×”: ×—×¦×™× â†â†’â†‘â†“</p>
                    <p>âš”ï¸ ×ª×§×™×¤×” ×•×›×¨×™×™×”: D (×”×—×–×§ ×œ×—×•×¥)</p>
                    <p>ğŸ§± ×‘× ×™×™×ª ×§×™×¨×•×ª: ×¨×•×•×—</p>
                </div>

                <div style="margin: 15px 0;">
                    <h4 style="color: #2196F3; margin: 10px 0;">ğŸ“± ××’×¢:</h4>
                    <p>ğŸƒ ×ª× ×•×¢×”: ×›×¤×ª×•×¨×™ ×”×—×¦×™× â–²â—€â–¶â–¼</p>
                    <p>âš”ï¸ ×ª×§×™×¤×” ×•×›×¨×™×™×”: ×›×¤×ª×•×¨ âš”ï¸ (×”×—×–×§ ×œ×—×•×¥)</p>
                    <p>ğŸ§± ×‘× ×™×™×ª ×§×™×¨×•×ª: ×›×¤×ª×•×¨ ğŸ§±</p>
                </div>

                <div style="margin: 15px 0; border-top: 1px solid #ddd; padding-top: 15px;">
                    <h4 style="color: #FF9800; margin: 10px 0;">ğŸ¯ ××˜×¨×ª ×”××©×—×§:</h4>
                    <p>ğŸ¯ ×”×¨×•×’ ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘×™×</p>
                    <p>âš”ï¸ ×”×¨×•×’ ×‘×•×¡×™× ×‘×©×œ×‘×™× 5, 10, 15, 20</p>
                    <p>â° ×™×© ×œ×š 70 ×©× ×™×•×ª ×œ×›×œ ×©×œ×‘</p>
                    <p>ğŸª¨ ×›×¨×” ×¡×œ×¢×™× ×œ××©××‘×™× ×•×‘× ×” ×—×•××•×ª ğŸ§±</p>
                    <p>ğŸ›’ ×©×“×¨×’ ××ª ×”×™×›×•×œ×•×ª ×©×œ×š ×‘×—× ×•×ª</p>
                </div>
            </div>
            <button id="startGame" class="start-btn">×”×ª×—×œ ×œ×©×—×§</button>
        </div>
    </div>
    <div class="hearts">â¤ï¸â¤ï¸â¤ï¸</div>
    <canvas id="gameCanvas"></canvas>
    <div id="shop">
        <h2>×—× ×•×ª</h2>
        <button id="buySpeed">××”×™×¨×•×ª +1 (50$)</button>
        <button id="buyRange">×˜×•×•×— +1 (50$)</button>
        <button id="buyMoney">×›×¡×£ +1 (50$)</button>
        <button id="buyHealth">×—×™×™× +1 (100$)</button>
        <button id="buyTime">×–××Ÿ +10 ×©× ×™×•×ª (25$)</button>
        <button id="buyAttackDuration">×ª×§×™×¤×” +1 ×©× ×™×™×” (50$)</button>
        <button id="shopContinue">×”××©×š</button>
    </div>
    <div id="victory">
        <h1>!× ×™×¦×—×•×Ÿ!</h1>
        <p>×”×©×œ××ª ××ª ×›×œ 20 ×”×©×œ×‘×™×!</p>
        <button id="playAgain">×©×—×§ ×©×•×‘</button>
    </div>
    <div id="gameOver">
        <h1>!××©×—×§ × ×’××¨</h1>
        <div id="gameOverStats">
            <p>×”×’×¢×ª ×œ×©×œ×‘: <span id="finalLevel">1</span></p>
            <p>×¡×”"×› ×”×¨×™×’×•×ª: <span id="finalKills">0</span></p>
            <p>×¡×”"×› ×›×¡×£ ×©× ×¦×‘×¨: <span id="finalMoney">0</span></p>
        </div>
        <button id="restartGame">×”×ª×—×œ ××—×“×©</button>
    </div>
    <div id="info">
        ×©×œ×‘: <span id="level">1</span><br>
        ×”×¨×™×’×•×ª: <span id="kills">0</span><br>
        ×›×¡×£: <span id="money">0</span><br>
        ×–××Ÿ: <span id="timer">70</span><br>
        ××ª×’×¨: <span id="challenge">×”×¨×•×’ 10 ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!</span>
    </div>

    <div id="controls">
        <div class="control-cluster dpad">
            <button id="up">â–²</button>
            <button id="left">â—€</button>
            <button id="right">â–¶</button>
            <button id="down">â–¼</button>
        </div>
        <div class="control-cluster actions">
            <button id="attack">âš”ï¸</button>
            <button id="place">ğŸ§±</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();
        window.addEventListener("resize", setCanvasSize);

        // Background images for different level ranges
        const backgroundImages = {
            bkg1: new Image(),
            bkg2: new Image(),
            bkg3: new Image(),
            bkg4: new Image()
        };
        
        // Player image
        const playerImage = new Image();
        playerImage.src = 'player.jpeg';
        playerImage.onload = () => console.log('player.jpeg loaded successfully');
        playerImage.onerror = () => console.error('Failed to load player.jpeg');
        
        // Load background images
        backgroundImages.bkg1.src = 'bkg1.jpeg';
        backgroundImages.bkg2.src = 'bkg2.jpeg';
        backgroundImages.bkg3.src = 'bkg3.jpeg';
        backgroundImages.bkg4.src = 'bkg4.jpeg';
        
        // Add load event listeners for debugging
        backgroundImages.bkg1.onload = () => console.log('bkg1.jpeg loaded successfully');
        backgroundImages.bkg2.onload = () => console.log('bkg2.jpeg loaded successfully');
        backgroundImages.bkg3.onload = () => console.log('bkg3.jpeg loaded successfully');
        backgroundImages.bkg4.onload = () => console.log('bkg4.jpeg loaded successfully');
        backgroundImages.bkg1.onerror = () => console.error('Failed to load bkg1.jpeg');
        backgroundImages.bkg2.onerror = () => console.error('Failed to load bkg2.jpeg');
        backgroundImages.bkg3.onerror = () => console.error('Failed to load bkg3.jpeg');
        backgroundImages.bkg4.onerror = () => console.error('Failed to load bkg4.jpeg');
        
        // Function to get appropriate background for current level
        function getCurrentBackground() {
            if (level >= 1 && level <= 5) {
                return backgroundImages.bkg1;
            } else if (level >= 6 && level <= 10) {
                return backgroundImages.bkg2;
            } else if (level >= 11 && level <= 15) {
                return backgroundImages.bkg3;
            } else if (level >= 16 && level <= 20) {
                return backgroundImages.bkg4;
            }
            // Default fallback
            return backgroundImages.bkg1;
        }
        
        // Track current background to detect changes
        let currentBackgroundName = '';
        
        // Function to draw background
        function drawBackground() {
            const bgImage = getCurrentBackground();
                       
            if (bgImage.complete) {
                // Draw background image to fill entire canvas
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback to solid color if image not loaded
                ctx.fillStyle = "#87ceeb";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        const welcomeScreen = document.getElementById("welcomeScreen");
        const startGameButton = document.getElementById("startGame");
        const heartsDisplay = document.querySelector(".hearts");
        const shopElement = document.getElementById("shop");
        const victoryElement = document.getElementById("victory");
        const gameOverElement = document.getElementById("gameOver");
        const playAgainButton = document.getElementById("playAgain");
        const restartGameButton = document.getElementById("restartGame");
        const finalLevelDisplay = document.getElementById("finalLevel");
        const finalKillsDisplay = document.getElementById("finalKills");
        const finalMoneyDisplay = document.getElementById("finalMoney");
        const buySpeedButton = document.getElementById("buySpeed");
        const buyRangeButton = document.getElementById("buyRange");
        const buyMoneyButton = document.getElementById("buyMoney");
        const buyHealthButton = document.getElementById("buyHealth");
        const buyTimeButton = document.getElementById("buyTime");
        const buyAttackDurationButton = document.getElementById("buyAttackDuration");
        const shopContinueButton = document.getElementById("shopContinue");
        const levelDisplay = document.getElementById("level");
        const killsDisplay = document.getElementById("kills");
        const moneyDisplay = document.getElementById("money");
        const timerDisplay = document.getElementById("timer");
        const challengeDisplay = document.getElementById("challenge");
        const infoDisplay = document.getElementById("info");

        const upButton = document.getElementById("up");
        const downButton = document.getElementById("down");
        const leftButton = document.getElementById("left");
        const rightButton = document.getElementById("right");
        const placeButton = document.getElementById("place");
        const attackButton = document.getElementById("attack");

        let level = 1;
        let kills = 0;
        let weaponDamage = 50;
        let money = 0;
        let enemySpawnInterval = 1000;
        let enemiesToKillForLevel = 10;
        let playerSpeed = 5;
        let attackRange = 50;
        let moneyPerKill = 5;
        let gameActive = false;  // Start with game inactive
        let spawnEnemiesEnabled = false;
        let gameStarted = false;
        let bossKilled = false;
        let baseLevelTime = 70;  // Base time for each level (can be upgraded)
        let levelTimeRemaining = 70;
        let levelStartTime = Date.now();
        let maxHearts = 3;  // Maximum hearts (can be upgraded in shop)
        let attackStartTime = 0;
        let attackEnded = false;
        let attackDuration = 3000;  // 3 seconds of attack (upgradeable)

        // --- Google Analytics Event Tracking ---
        function trackEvent(eventName, eventParams = {}) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, eventParams);
            } else {
                console.log(`GA Event (gtag not found): ${eventName}`, eventParams);
            }
        }
        // ------------------------------------

        const player = {
            x: 50,
            y: canvas.height - 100,
            width: 30,
            height: 30,
            color: "green",
            speed: playerSpeed,
            hearts: 3,
            inventory: [],
            rotation: 0,  // Player facing direction in degrees (0=right, 90=down, 270=up)
            facingLeft: false  // Track if player is facing left for horizontal mirroring
        };

        const hills = [];
        for (let i = 0; i < 10; i++) {
            hills.push({
                x: Math.random() * (canvas.width - 50),
                y: Math.random() * (canvas.height - 50),
                width: 50,
                height: 50,
                color: "brown",
                resources: 5
            });
        }

        const enemies = [];
        const projectiles = [];
        const fireballs = [];
        const poisonBottles = [];
        const miniBosses = [];
        const builtBlocks = [];
        let lastFortifyTime = 0;
        const fortifyInterval = 5000;

        function spawnEnemies() {
            // Check if this is a boss level (5, 10, 15, 20)
            const isBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
            
            // Always spawn regular enemies
            for (let i = 0; i < level * 2; i++) {
                enemies.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 30,
                    height: 30,
                    color: Math.random() > 0.5 ? "yellow" : "red",
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    health: 10 + level * 2,
                    isFortified: false,
                    fortifyColor: "black",
                    isBoss: false
                });
            }
            
            // Additionally spawn boss on boss levels
            if (isBossLevel) {
                // Determine boss lives based on level
                let bossLives;
                if (level === 5) bossLives = 2;
                else if (level === 10) bossLives = 4;
                else if (level === 15) bossLives = 7;
                else if (level === 20) bossLives = 10;
                
                enemies.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 45,  // Slightly larger
                    height: 45,
                    color: "orange",
                    dx: Math.random() > 0.5 ? 0.8 : -0.8,  // Slower than normal enemies
                    dy: Math.random() > 0.5 ? 0.8 : -0.8,
                    health: 50 + level * 5,  // Much more health
                    isBoss: true,
                    lastShot: Date.now(),  // Initialize with current time
                    lastFireballShot: Date.now() - 8000,  // Initialize fireball shot time (start with 2s delay for testing)
                    lastPoisonShot: Date.now() - 8000,  // Initialize poison shot time (start with 2s delay for testing)
                    lastMiniBossSpawn: Date.now() - 8000,  // Initialize mini-boss spawn time (start with 2s delay for testing)
                    lives: bossLives,
                    maxLives: bossLives,
                    hitFlash: 0,  // For hit animation
                    protectionEndTime: 0  // When protection dome expires
                });
                if (level === 10) {
                    console.log("Level 10 boss created with fireball capability!");
                }
                if (level === 15) {
                    console.log("Level 15 boss created with poison bottle capability!");
                }
                if (level === 20) {
                    console.log("Level 20 boss created with mini-boss spawning capability!");
                }
                bossKilled = false;
            }
        }
        spawnEnemies();

        function reinforceEnemies() {
            enemies.forEach(enemy => {
                enemy.health += 2;
                enemy.dx *= 1.1;
                enemy.dy *= 1.1;
            });
        }

        function spawnNewEnemy() {
            // Continue spawning regular enemies even on boss levels
            if (spawnEnemiesEnabled) {
                const enemyColor = Math.random() > 0.5 ? "yellow" : "red";
                const newEnemy = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 30,
                    height: 30,
                    color: enemyColor,
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    health: 10 + level * 2,
                    isBoss: false
                };
                enemies.push(newEnemy);
            }
        }
        setInterval(() => {
            reinforceEnemies();
            spawnNewEnemy();
        }, 4000);

        const keys = {};
        window.addEventListener("keydown", (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'Enter') {
                resetGame();
            }
            if (e.key === '0') {
                if (!gameActive) {
                    nextLevel();
                }
            }
        });
        window.addEventListener("keyup", (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        function handleControl(button, key) {
            function press(e) {
                e.preventDefault();
                keys[key] = true;
            }
            function release(e) {
                e.preventDefault();
                keys[key] = false;
            }
            if (button) {
                button.addEventListener("mousedown", press);
                button.addEventListener("mouseup", release);
                button.addEventListener("mouseleave", release);
                button.addEventListener("touchstart", press, { passive: false });
                button.addEventListener("touchend", release);
                button.addEventListener("touchcancel", release);
            }
        }

        handleControl(upButton, "arrowup");
        handleControl(downButton, "arrowdown");
        handleControl(leftButton, "arrowleft");
        handleControl(rightButton, "arrowright");
        handleControl(placeButton, " ");
        handleControl(attackButton, "d");

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function movePlayer() {
            let newX = player.x;
            let newY = player.y;

            // Track movement and update rotation/facing direction
            let moved = false;
            if (keys["arrowright"]) {
                newX += player.speed;
                player.rotation = 0;    // Face right
                player.facingLeft = false;
                moved = true;
            }
            if (keys["arrowleft"]) {
                newX -= player.speed;
                player.rotation = 0;    // Same rotation as right, but will be mirrored
                player.facingLeft = true;
                moved = true;
            }
            if (keys["arrowup"]) {
                newY -= player.speed;
                player.rotation = 270;  // Face up
                player.facingLeft = false;
                moved = true;
            }
            if (keys["arrowdown"]) {
                newY += player.speed;
                player.rotation = 90;   // Face down
                player.facingLeft = false;
                moved = true;
            }

            let collision = false;
            for (let hill of hills) {
                if (checkCollision({...player, x: newX, y: newY}, hill)) {
                    collision = true;
                    break;
                }
            }
            if (!collision) {
                for (let block of builtBlocks) {
                    if (checkCollision({...player, x: newX, y: newY}, block)) {
                        collision = true;
                        break;
                    }
                }
            }

            if (!collision) {
                player.x = newX;
                player.y = newY;
            }

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
        }

        function mineHills() {
            hills.forEach((hill, index) => {
                if (
                    player.x < hill.x + hill.width &&
                    player.x + player.width > hill.x &&
                    player.y < hill.y + hill.height &&
                    player.y + player.height > hill.y &&
                    keys["g"]
                ) {
                    player.inventory.push({ color: hill.color });
                    player.inventory.push({ color: hill.color });
                    hill.resources--;
                    if (hill.resources <= 0) {
                        hills.splice(index, 1);
                        player.inventory.push({ color: hill.color });
                        player.inventory.push({ color: hill.color });
                    }
                }
            });
        }

        function placeBlock() {
            if (keys[" "] && player.inventory.length > 0) {
                const block = player.inventory.pop();
                const newBlock = {
                    x: player.x + 40,
                    y: player.y,
                    width: 30,
                    height: 30,
                    color: block.color
                };

                let collision = false;
                for (let builtBlock of builtBlocks) {
                    if (checkCollision(newBlock, builtBlock)) {
                        collision = true;
                        break;
                    }
                }
                for (let hill of hills) {
                    if (checkCollision(newBlock, hill)) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    builtBlocks.push(newBlock);
                }
            }
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision({...enemy, x: newX, y: newY}, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision({...enemy, x: newX, y: newY}, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
                else{
                    enemy.dx *= -1;
                    enemy.dy *= -1;
                }

                if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) enemy.dx *= -1;
                if (enemy.y <= 0 || enemy.y + enemy.height >= canvas.height) enemy.dy *= -1;

                // Boss shooting in 8 directions
                if (enemy.isBoss && Date.now() - enemy.lastShot > 1500) {
                    enemy.lastShot = Date.now();
                    // 8 directions: N, NE, E, SE, S, SW, W, NW
                    const directions = [
                        {dx: 0, dy: -2},   // North
                        {dx: 1.4, dy: -1.4}, // Northeast
                        {dx: 2, dy: 0},    // East
                        {dx: 1.4, dy: 1.4},  // Southeast
                        {dx: 0, dy: 2},    // South
                        {dx: -1.4, dy: 1.4}, // Southwest
                        {dx: -2, dy: 0},   // West
                        {dx: -1.4, dy: -1.4} // Northwest
                    ];
                    
                    directions.forEach(dir => {
                        let projectileCollision = false;
                        const newProjectilePos = {
                            x: enemy.x + enemy.width/2 + dir.dx * 10,
                            y: enemy.y + enemy.height/2 + dir.dy * 10,
                            width: 5,
                            height: 5
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newProjectilePos, hill)) {
                                projectileCollision = true;
                                break;
                            }
                        }
                        if (!projectileCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newProjectilePos, block)) {
                                    projectileCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!projectileCollision) {
                            projectiles.push({ 
                                x: enemy.x + enemy.width/2, 
                                y: enemy.y + enemy.height/2, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 5,
                                height: 5
                            });
                        }
                    });
                }
                
                // Level 10 boss fireball shooting (every 10 seconds, 4 directions)
                if (enemy.isBoss && level === 10 && Date.now() - enemy.lastFireballShot > 10000) {
                    console.log("Level 10 boss firing fireballs!");
                    enemy.lastFireballShot = Date.now();
                    // 4 cardinal directions for fireballs
                    const fireballDirections = [
                        {dx: 0, dy: -1.5},  // North
                        {dx: 1.5, dy: 0},   // East
                        {dx: 0, dy: 1.5},   // South
                        {dx: -1.5, dy: 0}   // West
                    ];
                    
                    fireballDirections.forEach(dir => {
                        let fireballCollision = false;
                        const newFireballPos = {
                            x: enemy.x + enemy.width/2 + dir.dx * 10,
                            y: enemy.y + enemy.height/2 + dir.dy * 10,
                            width: 12,
                            height: 12
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newFireballPos, hill)) {
                                fireballCollision = true;
                                break;
                            }
                        }
                        if (!fireballCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newFireballPos, block)) {
                                    fireballCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!fireballCollision) {
                            console.log("Creating fireball in direction:", dir);
                            fireballs.push({ 
                                x: enemy.x + enemy.width/2, 
                                y: enemy.y + enemy.height/2, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 12,
                                height: 12
                            });
                        }
                    });
                }
                
                // Level 15 boss poison bottle shooting (every 10 seconds, smart tracking, only 1 at a time)
                if (enemy.isBoss && level === 15 && Date.now() - enemy.lastPoisonShot > 10000 && poisonBottles.length === 0) {
                    console.log("Level 15 boss firing poison bottle!");
                    enemy.lastPoisonShot = Date.now();
                    
                    let poisonCollision = false;
                    const newPoisonPos = {
                        x: enemy.x + enemy.width/2,
                        y: enemy.y + enemy.height/2,
                        width: 15,
                        height: 15
                    };
                    
                    // Check initial collision
                    for (let hill of hills) {
                        if(checkCollision(newPoisonPos, hill)) {
                            poisonCollision = true;
                            break;
                        }
                    }
                    if (!poisonCollision) {
                        for (let block of builtBlocks) {
                            if(checkCollision(newPoisonPos, block)) {
                                poisonCollision = true;
                                break;
                            }
                        }
                    }
                    
                    if (!poisonCollision) {
                        console.log("Creating poison bottle with player tracking! (Only 1 allowed at a time)");
                        poisonBottles.push({ 
                            x: enemy.x + enemy.width/2, 
                            y: enemy.y + enemy.height/2, 
                            targetX: player.x + player.width/2,
                            targetY: player.y + player.height/2,
                            speed: 2,
                            width: 15,
                            height: 15,
                            updateTargetTime: Date.now()
                        });
                    }
                }
                
                // Level 20 boss mini-boss spawning (every 10 seconds, 2 mini-bosses)
                if (enemy.isBoss && level === 20 && Date.now() - enemy.lastMiniBossSpawn > 10000) {
                    console.log("Level 20 boss spawning 2 mini-bosses!");
                    enemy.lastMiniBossSpawn = Date.now();
                    
                    // Spawn 2 mini-bosses
                    for (let i = 0; i < 2; i++) {
                        let spawnX, spawnY;
                        let attempts = 0;
                        
                        // Try to find a good spawn position (not colliding with obstacles)
                        do {
                            spawnX = Math.random() * (canvas.width - 30);
                            spawnY = Math.random() * (canvas.height - 30);
                            attempts++;
                        } while (attempts < 10); // Limit attempts to prevent infinite loop
                        
                        console.log(`Creating mini-boss ${i + 1} at position (${spawnX}, ${spawnY})`);
                        miniBosses.push({
                            x: spawnX,
                            y: spawnY,
                            width: 25,  // Smaller than main boss (45)
                            height: 25,
                            color: "purple",  // Different color to distinguish from main boss
                            dx: Math.random() > 0.5 ? 1.5 : -1.5,  // Faster than main boss (0.8)
                            dy: Math.random() > 0.5 ? 1.5 : -1.5,
                            health: 30,  // Less health than main boss
                            isBoss: false,  // Not a main boss
                            isMiniBoss: true,
                            lives: 2,
                            maxLives: 2,
                            hitFlash: 0,
                            protectionEndTime: 0,
                            lastShot: Date.now()
                        });
                    }
                }
                // Normal yellow enemy shooting
                else if (enemy.color === "yellow" && Math.random() < 0.01) {
                    let projectileCollision = false;
                    const newProjectileX = enemy.x - 2;
                    for (let hill of hills)
                    {
                        if(checkCollision({x: newProjectileX, y: enemy.y, width: 5, height: 5}, hill))
                        {
                            projectileCollision = true;
                            break;
                        }
                    }
                    if (!projectileCollision)
                    {
                        for (let block of builtBlocks)
                        {
                            if(checkCollision({x: newProjectileX, y: enemy.y, width: 5, height: 5}, block))
                            {
                                projectileCollision = true;
                                break;
                            }
                        }
                    }
                    if (!projectileCollision)
                    {
                        projectiles.push({ x: enemy.x, y: enemy.y, dx: -2, dy: 0, width: 5, height: 5 });
                    }
                }
            });
        }

        function moveProjectiles() {
            projectiles.forEach((projectile, index) => {
                projectile.x += projectile.dx;
                projectile.y += projectile.dy || 0;  // Handle dy for boss projectiles

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision(projectile, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision(projectile, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (collision) {
                    projectiles.splice(index, 1);
                    return;
                }

                if (projectile.x < 0 || projectile.x > canvas.width || 
                    projectile.y < 0 || projectile.y > canvas.height) {
                    projectiles.splice(index, 1);
                }

                if (
                    projectile.x < player.x + player.width &&
                    projectile.x + (projectile.width || 5) > player.x &&
                    projectile.y < player.y + player.height &&
                    projectile.y + (projectile.height || 5) > player.y
                ) {
                    player.hearts--;
                    projectiles.splice(index, 1);
                    if (player.hearts <= 0) {
                        alert("Game Over!");
                        player.hearts = 0;
                    }
                }
            });
        }

        function moveFireballs() {
            if (fireballs.length > 0) {
                console.log("Moving", fireballs.length, "fireballs");
            }
            fireballs.forEach((fireball, index) => {
                fireball.x += fireball.dx;
                fireball.y += fireball.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision(fireball, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision(fireball, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (collision) {
                    fireballs.splice(index, 1);
                    return;
                }

                if (fireball.x < 0 || fireball.x > canvas.width || 
                    fireball.y < 0 || fireball.y > canvas.height) {
                    fireballs.splice(index, 1);
                }

                // Fireball collision with player - deals 2 damage
                if (
                    fireball.x < player.x + player.width &&
                    fireball.x + fireball.width > player.x &&
                    fireball.y < player.y + player.height &&
                    fireball.y + fireball.height > player.y
                ) {
                    player.hearts -= 2;  // Fireballs deal 2 damage
                    fireballs.splice(index, 1);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                    }
                }
            });
        }

        function movePoisonBottles() {
            if (poisonBottles.length > 0) {
                console.log("Moving", poisonBottles.length, "poison bottles");
            }
            poisonBottles.forEach((poison, index) => {
                // Update target position every 500ms for smart tracking
                if (Date.now() - poison.updateTargetTime > 500) {
                    poison.targetX = player.x + player.width/2;
                    poison.targetY = player.y + player.height/2;
                    poison.updateTargetTime = Date.now();
                }
                
                // Calculate direction towards target
                const dx = poison.targetX - poison.x;
                const dy = poison.targetY - poison.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Normalize direction and apply speed
                    poison.x += (dx / distance) * poison.speed;
                    poison.y += (dy / distance) * poison.speed;
                }

                // Check collision with hills (rocks) - destroy rock but continue
                for (let h = hills.length - 1; h >= 0; h--) {
                    const hill = hills[h];
                    if (checkCollision(poison, hill)) {
                        console.log("Poison bottle destroyed a rock!");
                        hills.splice(h, 1);  // Destroy the rock
                        // Poison bottle continues moving, doesn't get destroyed
                    }
                }
                
                // Check collision with built blocks (walls) - poison bottle gets destroyed
                let wallCollision = false;
                for (let block of builtBlocks) {
                    if (checkCollision(poison, block)) {
                        wallCollision = true;
                        break;
                    }
                }

                if (wallCollision) {
                    console.log("Poison bottle hit wall and was destroyed!");
                    poisonBottles.splice(index, 1);
                    return;
                }

                // Remove if off screen
                if (poison.x < -20 || poison.x > canvas.width + 20 || 
                    poison.y < -20 || poison.y > canvas.height + 20) {
                    console.log("Poison bottle went off screen and was removed");
                    poisonBottles.splice(index, 1);
                    return;
                }

                // Poison bottle collision with player - deals 1 damage and reduces stats
                if (checkCollision(poison, player)) {
                    console.log("Poison bottle hit player! Reducing stats...");
                    player.hearts -= 1;  // Reduce 1 life
                    attackRange = Math.max(10, attackRange - 1);  // Reduce 1 range (minimum 10)
                    player.speed = Math.max(1, player.speed - 1);  // Reduce 1 speed (minimum 1)
                    playerSpeed = player.speed;  // Update player speed
                    poisonBottles.splice(index, 1);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                    }
                }
            });
        }

        function moveMiniBosses() {
            if (miniBosses.length > 0) {
                console.log("Moving", miniBosses.length, "mini-bosses");
            }
            miniBosses.forEach((miniBoss, index) => {
                // Move mini-boss
                let newX = miniBoss.x + miniBoss.dx;
                let newY = miniBoss.y + miniBoss.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision({...miniBoss, x: newX, y: newY}, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision({...miniBoss, x: newX, y: newY}, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    miniBoss.x = newX;
                    miniBoss.y = newY;
                } else {
                    miniBoss.dx *= -1;
                    miniBoss.dy *= -1;
                }

                // Bounce off walls
                if (miniBoss.x <= 0 || miniBoss.x + miniBoss.width >= canvas.width) miniBoss.dx *= -1;
                if (miniBoss.y <= 0 || miniBoss.y + miniBoss.height >= canvas.height) miniBoss.dy *= -1;

                // Mini-boss shooting (faster than normal enemies)
                if (Date.now() - miniBoss.lastShot > 800) {  // Shoot every 0.8 seconds
                    miniBoss.lastShot = Date.now();
                    // 4 directions: N, E, S, W
                    const directions = [
                        {dx: 0, dy: -2.5},   // North
                        {dx: 2.5, dy: 0},    // East
                        {dx: 0, dy: 2.5},    // South
                        {dx: -2.5, dy: 0}    // West
                    ];
                    
                    directions.forEach(dir => {
                        let projectileCollision = false;
                        const newProjectilePos = {
                            x: miniBoss.x + miniBoss.width/2 + dir.dx * 10,
                            y: miniBoss.y + miniBoss.height/2 + dir.dy * 10,
                            width: 5,
                            height: 5
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newProjectilePos, hill)) {
                                projectileCollision = true;
                                break;
                            }
                        }
                        if (!projectileCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newProjectilePos, block)) {
                                    projectileCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!projectileCollision) {
                            projectiles.push({ 
                                x: miniBoss.x + miniBoss.width/2, 
                                y: miniBoss.y + miniBoss.height/2, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 5,
                                height: 5
                            });
                        }
                    });
                }

                // Check collision with player (mini-bosses deal damage on contact)
                if (checkCollision(miniBoss, player)) {
                    player.hearts--;
                    miniBosses.splice(index, 1);
                    console.log("Mini-boss hit player and was destroyed!");
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                    }
                }
            });
        }

        function attackEnemies() {
            const currentTime = Date.now();
            
            // Check if attack button is pressed
            if (keys["d"]) {
                // If attack just started, record start time
                if (attackStartTime === 0 && !attackEnded) {
                    attackStartTime = currentTime;
                }
                
                // Check if attack duration has been exceeded
                if (attackStartTime > 0 && currentTime - attackStartTime > attackDuration) {
                    // Stop attacking after 3 seconds
                    attackEnded = true;
                    attackStartTime = 0;
                }
                
                // Only attack if within attack duration and not ended
                if (attackStartTime > 0 && !attackEnded) {
                    performAttack();
                }
            } else {
                // Reset when button is released
                attackStartTime = 0;
                attackEnded = false;
            }
        }

        function performAttack() {
            let targetIndex = -1;
            let closestDistance = Infinity;
                enemies.forEach((enemy, index) => {
                    const distance = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    if (distance < closestDistance && distance < attackRange) {
                        closestDistance = distance;
                        targetIndex = index;
                    }
                });

                if (targetIndex !== -1) {
                    const hitEnemy = enemies[targetIndex];
                    
                    if (hitEnemy.isBoss) {
                        // Check if boss is currently protected
                        if (Date.now() < hitEnemy.protectionEndTime) {
                            // Boss is protected, cannot be hit
                            return;
                        }
                        
                        hitEnemy.lives--;
                        hitEnemy.hitFlash = Date.now();  // Start hit flash animation
                        hitEnemy.protectionEndTime = Date.now() + 3000;  // 3 seconds of protection
                        
                        if (hitEnemy.lives <= 0) {
                            enemies.splice(targetIndex, 1);
                            kills += 5;  // Boss gives 5 kills
                            money += 10; // Boss gives 10 money
                            bossKilled = true;
                            trackEvent('boss_defeated', { level: level }); // GA Event
                        }
                    } else {
                        enemies.splice(targetIndex, 1);
                        kills++;
                        money += moneyPerKill;
                        console.log("Enemy killed!");
                    }
                }

                // Check for mini-boss attacks
                let miniBossTargetIndex = -1;
                let miniBossClosestDistance = Infinity;
                miniBosses.forEach((miniBoss, index) => {
                    const distance = Math.hypot(player.x - miniBoss.x, player.y - miniBoss.y);
                    if (distance < miniBossClosestDistance && distance < attackRange) {
                        miniBossClosestDistance = distance;
                        miniBossTargetIndex = index;
                    }
                });

                if (miniBossTargetIndex !== -1) {
                    const hitMiniBoss = miniBosses[miniBossTargetIndex];
                    
                    // Check if mini-boss is currently protected
                    if (Date.now() < hitMiniBoss.protectionEndTime) {
                        // Mini-boss is protected, cannot be hit
                        return;
                    }
                    
                    hitMiniBoss.lives--;
                    hitMiniBoss.hitFlash = Date.now();  // Start hit flash animation
                    hitMiniBoss.protectionEndTime = Date.now() + 1500;  // 1.5 seconds of protection
                    
                    if (hitMiniBoss.lives <= 0) {
                        miniBosses.splice(miniBossTargetIndex, 1);
                        kills += 2;  // Mini-boss gives 2 kills
                        money += 8;  // Mini-boss gives 8 money
                        console.log("Mini-boss defeated!");
                    }
                }

                for (let i = builtBlocks.length - 1; i >= 0; i--) {
                    const block = builtBlocks[i];
                    const distance = Math.hypot(player.x - block.x, player.y - block.y);
                    if (distance < attackRange) {
                        builtBlocks.splice(i, 1);
                        console.log("Block removed!");
                        break;
                    }
                }

                hills.forEach((hill, index) => {
                    const distance = Math.hypot(player.x - hill.x, player.y - hill.y);
                    if (distance < attackRange) {
                        player.inventory.push({ color: hill.color });
                        player.inventory.push({ color: hill.color });
                        hill.resources--;
                        if (hill.resources <= 0) {
                            hills.splice(index, 1);
                            player.inventory.push({ color: hill.color });
                            player.inventory.push({ color: hill.color });
                        }
                    }
                });
        }

        function advanceLevel() {
            level++;
            levelDisplay.textContent = level;
            trackEvent('level_complete', { level: level }); // GA Event
            
            // Check for victory condition after completing level 20
            if (level > 20) {
                gameActive = false;
                spawnEnemiesEnabled = false;
                shopElement.style.display = "none";
                victoryElement.style.display = "flex";
                trackEvent('victory'); // GA Event
                return;
            }
            
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            kills = 0;
            killsDisplay.textContent = kills;
            enemiesToKillForLevel += 5;
            
            // Update challenge text based on level type
            const nextIsBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
            if (nextIsBossLevel) {
                challengeDisplay.textContent = "×”×¨×•×’ ××ª ×”×‘×•×¡ ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!";
            } else {
                challengeDisplay.textContent = `×”×¨×•×’ ${enemiesToKillForLevel} ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!`;
            }
            
            enemySpawnInterval = Math.max(100, enemySpawnInterval - 100);
            gameActive = true;
            shopElement.style.display = "none";

            player.x = 50;
            player.y = canvas.height - 100;
            player.hearts = maxHearts;  // Use upgraded max hearts
            player.facingLeft = false;  // Reset facing direction
            hills.splice(0, hills.length);
            for (let i = 0; i < 10; i++) {
                hills.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 50,
                    height: 50,
                    color: "brown",
                    resources: 5
                });
            }
            playerSpeed = playerSpeed;
            attackRange = attackRange;
            moneyPerKill = moneyPerKill;
            
            // Clear existing enemies and spawn new ones for the new level
            enemies.splice(0, enemies.length);
            projectiles.splice(0, projectiles.length);
            fireballs.splice(0, fireballs.length);
            poisonBottles.splice(0, poisonBottles.length);
            miniBosses.splice(0, miniBosses.length);
            bossKilled = false;
            
            // Reset timer for new level
            levelTimeRemaining = baseLevelTime;
            levelStartTime = Date.now();
            timerDisplay.textContent = levelTimeRemaining;
            
            spawnEnemies();
            
            gameLoop()
        }

        function showGameOver(reason) {
            gameActive = false;
            spawnEnemiesEnabled = false;
            trackEvent('game_over', { level: level, reason: reason }); // GA Event
            
            // Update final stats
            finalLevelDisplay.textContent = level;
            finalKillsDisplay.textContent = kills;
            finalMoneyDisplay.textContent = money;
            
            // Show game over screen
            gameOverElement.style.display = "flex";
            shopElement.style.display = "none";
            victoryElement.style.display = "none";
        }

        function resetGame() {
            level = 1;
            kills = 0;
            weaponDamage = 50;
            money = 0;
            player.x = 50;
            player.y = canvas.height - 100;
            maxHearts = 3;  // Reset max hearts when game restarts
            player.hearts = maxHearts;
            player.inventory = [];
            player.facingLeft = false;  // Reset facing direction
            hills.splice(0, hills.length);
            for (let i = 0; i < 10; i++) {
                hills.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 50,
                    height: 50,
                    color: "brown",
                    resources: 5
                });
            }
            enemies.splice(0, enemies.length);
            spawnEnemies();
            projectiles.splice(0, projectiles.length);
            fireballs.splice(0, fireballs.length);
            poisonBottles.splice(0, poisonBottles.length);
            miniBosses.splice(0, miniBosses.length);
            builtBlocks.splice(0, builtBlocks.length);
            enemySpawnInterval = 1000;
            enemiesToKillForLevel = 10;
            playerSpeed = 5;
            attackRange = 50;
            moneyPerKill = 5;
            gameActive = false;  // Don't start automatically
            gameStarted = false;
            shopElement.style.display = "none";
            victoryElement.style.display = "none";
            gameOverElement.style.display = "none";
            welcomeScreen.style.display = "flex";  // Show welcome screen again
            bossKilled = false;
            
            // Reset timer
            baseLevelTime = 70;  // Reset base time when game restarts
            levelTimeRemaining = baseLevelTime;
            levelStartTime = Date.now();
            
            // Reset attack state
            attackStartTime = 0;
            attackEnded = false;
            attackDuration = 3000;  // Reset attack duration to 3 seconds
            
            levelDisplay.textContent = level;
            killsDisplay.textContent = kills;
            moneyDisplay.textContent = money;
            timerDisplay.textContent = levelTimeRemaining;
            challengeDisplay.textContent = `×”×¨×•×’ ${enemiesToKillForLevel} ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!`;
            
            // Reset individual item prices
            speedPrice = 50;
            rangePrice = 50;
            moneyPrice = 50;
            healthPrice = 100;
            timePrice = 25;
            attackDurationPrice = 50;
            updateShopPrices();  // Update shop prices after game reset
            // Don't start game loop automatically
        }

        function drawChallenges() {
            ctx.fillStyle = "white";
            ctx.font = "16px Arial";
            ctx.fillText(challengeDisplay.textContent, 10, 100);
        }

        function draw() {
            // Draw level-appropriate background
            drawBackground();

            // Draw player with rotation and horizontal mirroring
            if (playerImage.complete) {
                ctx.save();
                // Move to player center for rotation
                ctx.translate(player.x + player.width/2, player.y + player.height/2);
                // Apply horizontal mirroring if facing left
                if (player.facingLeft) {
                    ctx.scale(-1, 1);
                }
                // Rotate based on player direction
                ctx.rotate(player.rotation * Math.PI / 180);
                // Draw player image centered
                ctx.drawImage(playerImage, -player.width/2, -player.height/2, player.width, player.height);
                ctx.restore();
            } else {
                // Fallback to rectangle if image not loaded
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            hills.forEach(hill => {
                // Draw rock emoji instead of colored rectangle
                ctx.font = "50px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸª¨", hill.x + hill.width/2, hill.y + hill.height - 5);
                ctx.textAlign = "start"; // Reset text alignment
            });

            builtBlocks.forEach(block => {
                // Draw brick emoji instead of colored rectangle
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸ§±", block.x + block.width/2, block.y + block.height - 5);
                ctx.textAlign = "start"; // Reset text alignment
            });

            enemies.forEach(enemy => {
                if (enemy.isBoss) {
                    // Boss hit flash effect
                    const timeSinceHit = Date.now() - enemy.hitFlash;
                    if (timeSinceHit < 300) {
                        // Flash white for 300ms after being hit
                        ctx.fillStyle = Math.floor(timeSinceHit / 50) % 2 === 0 ? "white" : enemy.color;
                    } else {
                        ctx.fillStyle = enemy.color;
                    }
                    
                    // Draw boss
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    
                    // Draw boss health bar
                    const barWidth = enemy.width;
                    const barHeight = 4;
                    const healthRatio = enemy.lives / enemy.maxLives;
                    
                    // Background (red)
                    ctx.fillStyle = "red";
                    ctx.fillRect(enemy.x, enemy.y - 15, barWidth, barHeight);
                    
                    // Health (green)
                    ctx.fillStyle = "lime";
                    ctx.fillRect(enemy.x, enemy.y - 15, barWidth * healthRatio, barHeight);
                    
                    // Draw protection dome if boss is protected
                    if (Date.now() < enemy.protectionEndTime) {
                        const centerX = enemy.x + enemy.width / 2;
                        const centerY = enemy.y + enemy.height / 2;
                        const domeRadius = enemy.width * 0.8;
                        
                        // Draw dome outline
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.strokeStyle = "cyan";
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // Draw semi-transparent dome fill
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
                        ctx.fill();
                    }
                } else {
                    // Regular enemy
                    ctx.fillStyle = enemy.color;
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                }
            });

            projectiles.forEach(projectile => {
                ctx.fillStyle = "black";
                ctx.fillRect(projectile.x, projectile.y, projectile.width || 5, projectile.height || 5);
            });

            fireballs.forEach(fireball => {
                // Draw fireball as fire emoji
                ctx.font = "16px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸ”¥", fireball.x + fireball.width/2, fireball.y + fireball.height - 2);
                ctx.textAlign = "start"; // Reset text alignment
            });

            miniBosses.forEach(miniBoss => {
                // Mini-boss hit flash effect
                const timeSinceHit = Date.now() - miniBoss.hitFlash;
                if (timeSinceHit < 300) {
                    // Flash white for 300ms after being hit
                    ctx.fillStyle = Math.floor(timeSinceHit / 50) % 2 === 0 ? "white" : miniBoss.color;
                } else {
                    ctx.fillStyle = miniBoss.color;
                }
                
                // Draw mini-boss
                ctx.fillRect(miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
                
                // Draw mini-boss health bar
                const barWidth = miniBoss.width;
                const barHeight = 3;
                const healthRatio = miniBoss.lives / miniBoss.maxLives;
                
                // Background (red)
                ctx.fillStyle = "red";
                ctx.fillRect(miniBoss.x, miniBoss.y - 10, barWidth, barHeight);
                
                // Health (green)
                ctx.fillStyle = "lime";
                ctx.fillRect(miniBoss.x, miniBoss.y - 10, barWidth * healthRatio, barHeight);
                
                // Draw protection dome if mini-boss is protected
                if (Date.now() < miniBoss.protectionEndTime) {
                    const centerX = miniBoss.x + miniBoss.width / 2;
                    const centerY = miniBoss.y + miniBoss.height / 2;
                    const domeRadius = miniBoss.width * 0.8;
                    
                    // Draw dome outline
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = "cyan";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw semi-transparent dome fill
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
                    ctx.fill();
                }
            });

            poisonBottles.forEach(poison => {
                // Draw poison bottle as poison emoji
                ctx.font = "18px Arial";
                ctx.textAlign = "center";
                ctx.fillText("â˜ ï¸", poison.x + poison.width/2, poison.y + poison.height - 2);
                ctx.textAlign = "start"; // Reset text alignment
            });

            drawChallenges();

            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            levelDisplay.textContent = level;
            killsDisplay.textContent = kills;
            moneyDisplay.textContent = `${money} $`;
            heartsDisplay.textContent = 'â¤ï¸'.repeat(player.hearts);

            // Only show attack circle when actively attacking
            if (keys["d"] && attackStartTime > 0 && !attackEnded) {
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, attackRange, 0, 2 * Math.PI);
                ctx.strokeStyle = "green";
                ctx.stroke();
            }
            
            // Show attack duration bar only when attacking
            if (attackStartTime > 0 && !attackEnded) {
                const attackProgress = (Date.now() - attackStartTime) / attackDuration;
                const barWidth = 100;
                const barHeight = 8;
                const barX = player.x - (barWidth - player.width) / 2;
                const barY = player.y - 25;
                
                // Background
                ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Progress
                ctx.fillStyle = "green";
                ctx.fillRect(barX, barY, barWidth * Math.min(attackProgress, 1), barHeight);
                
                // Border
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        }

        function gameLoop() {
            if (gameActive) {
                // Update timer
                const timeElapsed = Math.floor((Date.now() - levelStartTime) / 1000);
                levelTimeRemaining = Math.max(0, baseLevelTime - timeElapsed);
                timerDisplay.textContent = levelTimeRemaining;
                
                // Check if time is up
                if (levelTimeRemaining <= 0) {
                    showGameOver("×–××Ÿ × ×’××¨!");
                    return;
                }
                
                movePlayer();
                placeBlock();
                moveEnemies();
                moveProjectiles();
                moveFireballs();
                movePoisonBottles();
                moveMiniBosses();
                attackEnemies();
                draw();

                enemies.forEach(enemy => {
                    if (enemy.color === "red" && checkCollision(player, enemy)) {
                        player.hearts--;
                        enemies.splice(enemies.indexOf(enemy), 1);
                        if (player.hearts <= 0) {
                            showGameOver("× ×’××¨×• ×”×—×™×™×!");
                        }
                    }
                });

                // Check level completion
                const isBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
                const levelComplete = isBossLevel ? bossKilled : kills >= enemiesToKillForLevel;
                
                if (levelComplete) {
                    gameActive = false;
                    spawnEnemiesEnabled = false;
                    shopElement.style.display = "flex";
                }
                if (player.hearts > 0) {
                    requestAnimationFrame(gameLoop);
                } else {
                    showGameOver("× ×’××¨×• ×”×—×™×™×!");
                }
            }
            else{
                draw();
            }
        }

        // Individual item prices that increase with each purchase
        let speedPrice = 50;
        let rangePrice = 50;
        let moneyPrice = 50;
        let healthPrice = 100;
        let timePrice = 25;
        let attackDurationPrice = 50;

        // Function to update shop button text with current prices
        function updateShopPrices() {
            buySpeedButton.textContent = `××”×™×¨×•×ª +1 (${speedPrice}$)`;
            buyRangeButton.textContent = `×˜×•×•×— +1 (${rangePrice}$)`;
            buyMoneyButton.textContent = `×›×¡×£ +1 (${moneyPrice}$)`;
            buyHealthButton.textContent = `×—×™×™× +1 (${healthPrice}$)`;
            buyTimeButton.textContent = `×–××Ÿ +10 ×©× ×™×•×ª (${timePrice}$)`;
            buyAttackDurationButton.textContent = `×ª×§×™×¤×” +1 ×©× ×™×™×” (${attackDurationPrice}$)`;
        }

        buySpeedButton.addEventListener("click", () => {
            if (money >= speedPrice) {
                money -= speedPrice;
                trackEvent('purchase', { item_name: 'speed_upgrade', value: speedPrice, currency: 'USD' }); // GA Event
                speedPrice += 5;  // Increase price for next purchase
                player.speed += 1;
                moneyDisplay.textContent = `${money} $`;
                playerSpeed = player.speed;
                updateShopPrices();  // Update button text with new price
            }
        });

        buyRangeButton.addEventListener("click", () => {
            if (money >= rangePrice) {
                money -= rangePrice;
                trackEvent('purchase', { item_name: 'range_upgrade', value: rangePrice, currency: 'USD' }); // GA Event
                rangePrice += 5;  // Increase price for next purchase
                attackRange += 10;
                moneyDisplay.textContent = `${money} $`;
                attackRange = attackRange;
                updateShopPrices();  // Update button text with new price
            }
        });

        buyMoneyButton.addEventListener("click", () => {
            if (money >= moneyPrice) {
                money -= moneyPrice;
                trackEvent('purchase', { item_name: 'money_per_kill_upgrade', value: moneyPrice, currency: 'USD' }); // GA Event
                moneyPrice += 5;  // Increase price for next purchase
                moneyPerKill += 1;
                moneyDisplay.textContent = `${money} $`;
                moneyPerKill = moneyPerKill;
                updateShopPrices();  // Update button text with new price
            }
        });

        buyHealthButton.addEventListener("click", () => {
            if (money >= healthPrice) {
                money -= healthPrice;
                trackEvent('purchase', { item_name: 'health_upgrade', value: healthPrice, currency: 'USD' }); // GA Event
                healthPrice += 5;  // Increase price for next purchase
                maxHearts += 1;  // Increase max hearts permanently
                player.hearts = maxHearts;  // Set current hearts to new max
                moneyDisplay.textContent = `${money} $`;
                heartsDisplay.textContent = 'â¤ï¸'.repeat(player.hearts);
                updateShopPrices();  // Update button text with new price
            }
        });

        buyTimeButton.addEventListener("click", () => {
            if (money >= timePrice) {
                money -= timePrice;
                trackEvent('purchase', { item_name: 'time_upgrade', value: timePrice, currency: 'USD' }); // GA Event
                timePrice += 5;  // Increase price for next purchase
                // Permanently increase base level time for all future levels
                baseLevelTime += 10;
                moneyDisplay.textContent = `${money} $`;
                updateShopPrices();  // Update button text with new price
            }
        });

        buyAttackDurationButton.addEventListener("click", () => {
            if (money >= attackDurationPrice) {
                money -= attackDurationPrice;
                trackEvent('purchase', { item_name: 'attack_duration_upgrade', value: attackDurationPrice, currency: 'USD' }); // GA Event
                attackDurationPrice += 5;  // Increase price for next purchase
                // Permanently increase attack duration by 1 second
                attackDuration += 1000;
                moneyDisplay.textContent = `${money} $`;
                updateShopPrices();  // Update button text with new price
            }
        });

        shopContinueButton.addEventListener("click", () => {
            if (!gameActive) {
                spawnEnemiesEnabled = true;
                advanceLevel();
            }
        });

        playAgainButton.addEventListener("click", () => {
            victoryElement.style.display = "none";
            spawnEnemiesEnabled = true;
            resetGame();
        });

        restartGameButton.addEventListener("click", () => {
            gameOverElement.style.display = "none";
            spawnEnemiesEnabled = true;
            resetGame();
        });

        startGameButton.addEventListener("click", () => {
            welcomeScreen.style.display = "none";
            gameStarted = true;
            gameActive = true;
            spawnEnemiesEnabled = true;
            updateShopPrices();  // Set initial shop prices
            trackEvent('game_start'); // GA Event
            setInterval(spawnNewEnemy, enemySpawnInterval);
            gameLoop();
        });
    </script>
</body>
</html>
