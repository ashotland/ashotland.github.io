<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EnemyBlock1 - by Shotland Games</title>
    <link rel="icon" href="favicon.png" type="image/x-icon">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-BXKSQPZ851"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-BXKSQPZ851'); // <-- âš ï¸ REPLACE WITH YOUR MEASUREMENT ID
    </script>
    <!-- Firebase SDKs (Compat builds for easy use in this script) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            overflow: hidden;
        }
        /* --- Auth / Leaderboard UI --- */
        #userBar {
            position: fixed;
            top: 0;
            right: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.65);
            color: #fff;
            z-index: 1100;
            font-size: 14px;
            direction: rtl;
        }
        #authControls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        #authControls input {
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #111;
            color: #fff;
        }
        #authControls button, #leaderboardToggle {
            padding: 6px 10px;
            border-radius: 4px;
            border: none;
            background: #4CAF50;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
        }
        #leaderboardToggle { background: #2196F3; }
        #authStatus { opacity: 0.9; }

        #leaderboardPanel {
            position: fixed;
            top: 54px;
            right: 10px;
            width: min(420px, 92vw);
            max-height: 70vh;
            overflow: auto;
            background: rgba(0,0,0,0.9);
            color: #fff;
            border-radius: 10px;
            border: 2px solid #2196F3;
            padding: 12px;
            z-index: 1090;
            display: none;
            direction: rtl;
        }
        #leaderboardPanel h3 { margin: 0 0 10px 0; }
        #leaderboardList { list-style: none; padding: 0; margin: 0; }
        #leaderboardList li { padding: 6px 8px; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .youRow { background: rgba(76, 175, 80, 0.15); border-radius: 6px; }
        #welcomeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .welcome-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: welcomeFadeIn 1s ease-out;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        @media (max-width: 768px) {
            .welcome-content {
                padding: 20px;
                margin: 10px;
                border-radius: 15px;
            }
            .welcome-content h1 {
                font-size: 32px !important;
            }
            .subtitle {
                font-size: 16px !important;
            }
            .game-instructions {
                padding: 15px !important;
                margin: 20px 0 !important;
            }
            .game-instructions h3 {
                font-size: 20px !important;
            }
            .game-instructions h4 {
                font-size: 16px !important;
            }
            .game-instructions p {
                font-size: 14px !important;
                margin: 8px 0 !important;
            }
            .start-btn {
                font-size: 20px !important;
                padding: 12px 30px !important;
            }
        }
        @keyframes welcomeFadeIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .welcome-icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            animation: iconFloat 3s ease-in-out infinite;
        }
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        .welcome-content h1 {
            font-size: 48px;
            color: #333;
            margin: 20px 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        .game-instructions {
            background: rgba(102, 126, 234, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 30px 0;
            text-align: right;
            direction: rtl;
        }
        .game-instructions p {
            margin: 10px 0;
            font-size: 16px;
            color: #444;
        }
        .start-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 24px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
        }
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(102, 126, 234, 0.4);
        }
        .start-btn:active {
            transform: translateY(-1px);
        }
        canvas {
            display: block;
            background: #000;
        }
        .hearts {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            color: red;
        }
        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            border-radius: 10px;
        }
        #shop button {
            margin: 5px;
            padding: 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            width: 200px;
        }
        #shop button:hover {
            background-color: #367c39;
        }
        #shop h2 {
            margin-bottom: 15px;
            font-size: 24px;
        }
        #victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 15;
            border-radius: 15px;
            border: 3px solid gold;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        #victory h1 {
            margin-bottom: 20px;
            font-size: 48px;
            color: gold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px gold;
            }
            to {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px gold, 0 0 30px gold;
            }
        }
        #victory p {
            margin-bottom: 25px;
            font-size: 20px;
            text-align: center;
        }
        #victory button {
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        #victory button:hover {
            background-color: #367c39;
            transform: scale(1.05);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 40px;
            display: none;
            flex-direction: column;
            align-items: center;
            z-index: 15;
            border-radius: 15px;
            border: 3px solid #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5);
        }
        #gameOver h1 {
            margin-bottom: 20px;
            font-size: 48px;
            color: #ff4444;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: gameOverGlow 2s ease-in-out infinite alternate;
        }
        @keyframes gameOverGlow {
            from {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 10px #ff4444;
            }
            to {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px #ff4444, 0 0 30px #ff4444;
            }
        }
        #gameOverStats {
            margin-bottom: 25px;
            text-align: center;
        }
        #gameOverStats p {
            margin: 10px 0;
            font-size: 18px;
        }
        #gameOverStats span {
            color: #ffdd44;
            font-weight: bold;
        }
        #gameOver button {
            padding: 15px 30px;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        #gameOver button:hover {
            background-color: #cc3333;
            transform: scale(1.05);
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 16px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
        }

        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 30px;
            pointer-events: none;
        }

        .control-cluster {
            pointer-events: auto;
        }
        
        .dpad {
            display: grid;
            grid-template-areas: ". up ." "left . right" ". down .";
            gap: 15px;
        }

        #up { grid-area: up; }
        #down { grid-area: down; }
        #left { grid-area: left; }
        #right { grid-area: right; }

        .actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        #controls button {
            width: 70px;
            height: 70px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            color: white;
            border-radius: 50%;
            font-size: 24px;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
        }

        #controls button:active {
            background: rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="userBar">
        <div id="authStatus">×œ× ××—×•×‘×¨</div>
        <div id="authControls">
            <input id="displayNameInput" type="text" placeholder="×©× ×ª×¦×•×’×”" style="width:120px;" />
            <input id="emailInput" type="email" placeholder="××™××™×™×œ" style="width:160px;" />
            <input id="passwordInput" type="password" placeholder="×¡×™×¡××”" style="width:120px;" />
            <button id="registerBtn">×”×¨×©××”</button>
            <button id="loginBtn">×”×ª×—×‘×¨×•×ª</button>
            <button id="logoutBtn" style="display:none; background:#ff4444;">×”×ª× ×ª×§×•×ª</button>
            <button id="leaderboardToggle">×˜×‘×œ×ª ××•×‘×™×œ×™×</button>
        </div>
    </div>
    <div id="leaderboardPanel">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
            <h3 style="margin:0;">×˜×‘×œ×ª ××•×‘×™×œ×™×</h3>
            <button id="leaderboardClose" aria-label="×¡×’×™×¨×”" title="×¡×’×•×¨" style="background:#ff4444;color:#fff;border:none;border-radius:6px;width:28px;height:28px;font-weight:700;cursor:pointer;">Ã—</button>
        </div>
        <ol id="leaderboardList"></ol>
        <p id="leaderboardNote" style="font-size:12px; opacity:0.8; margin-top:10px;">×”×“×™×¨×•×’ ×œ×¤×™ ×©×œ×‘ ×’×‘×•×” ×™×•×ª×¨ ×ª×—×™×œ×”, ×•××– ×œ×¤×™ ×–××Ÿ ××”×™×¨ ×™×•×ª×¨.</p>
    </div>
    <div id="welcomeScreen">
        <div class="welcome-content">
            <img src="favicon.png" alt="Game Icon" class="welcome-icon">
            <h1>EnemyBlock1</h1>
            <p class="subtitle">by Shotland Games</p>
            <div class="game-instructions">
                <h3 style="margin-top: 0; color: #333;">ğŸ® ××™×š ×œ×©×—×§</h3>
                
                <div style="margin: 15px 0;">
                    <h4 style="color: #4CAF50; margin: 10px 0;">âŒ¨ï¸ ××§×œ×“×ª:</h4>
                    <p>ğŸƒ ×ª× ×•×¢×”: ×—×¦×™× â†â†’â†‘â†“</p>
                    <p>âš”ï¸ ×ª×§×™×¤×” ×•×›×¨×™×™×”: D (×”×—×–×§ ×œ×—×•×¥)</p>
                    <p>ğŸ§± ×‘× ×™×™×ª ×§×™×¨×•×ª: ×¨×•×•×—</p>
                </div>

                <div style="margin: 15px 0;">
                    <h4 style="color: #2196F3; margin: 10px 0;">ğŸ“± ××’×¢:</h4>
                    <p>ğŸƒ ×ª× ×•×¢×”: ×›×¤×ª×•×¨×™ ×”×—×¦×™× â–²â—€â–¶â–¼</p>
                    <p>âš”ï¸ ×ª×§×™×¤×” ×•×›×¨×™×™×”: ×›×¤×ª×•×¨ âš”ï¸ (×”×—×–×§ ×œ×—×•×¥)</p>
                    <p>ğŸ§± ×‘× ×™×™×ª ×§×™×¨×•×ª: ×›×¤×ª×•×¨ ğŸ§±</p>
                </div>

                <div style="margin: 15px 0; border-top: 1px solid #ddd; padding-top: 15px;">
                    <h4 style="color: #FF9800; margin: 10px 0;">ğŸ¯ ××˜×¨×ª ×”××©×—×§:</h4>
                    <p>ğŸ¯ ×”×¨×•×’ ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘×™×</p>
                    <p>âš”ï¸ ×”×¨×•×’ ×‘×•×¡×™× ×‘×©×œ×‘×™× 5, 10, 15, 20</p>
                    <p>â° ×™×© ×œ×š 70 ×©× ×™×•×ª ×œ×›×œ ×©×œ×‘</p>
                    <p>ğŸª¨ ×›×¨×” ×¡×œ×¢×™× ×œ××©××‘×™× ×•×‘× ×” ×—×•××•×ª ğŸ§±</p>
                    <p>ğŸ›’ ×©×“×¨×’ ××ª ×”×™×›×•×œ×•×ª ×©×œ×š ×‘×—× ×•×ª</p>
                </div>
            </div>
            <button id="startGame" class="start-btn">×”×ª×—×œ ×œ×©×—×§</button>
        </div>
    </div>
    <div class="hearts">â¤ï¸â¤ï¸â¤ï¸</div>
    <canvas id="gameCanvas"></canvas>
    <div id="shop">
        <h2>×—× ×•×ª</h2>
        <button id="buySpeed">××”×™×¨×•×ª +1 (50$)</button>
        <button id="buyRange">×˜×•×•×— +1 (50$)</button>
        <button id="buyMoney">×›×¡×£ +1 (50$)</button>
        <button id="buyHealth">×—×™×™× +1 (100$)</button>
        <button id="buyTime">×–××Ÿ +10 ×©× ×™×•×ª (25$)</button>
        <div id="purchaseHistory" style="margin: 15px 0; padding: 10px; background-color: rgba(255, 255, 255, 0.1); border-radius: 5px; display: none;">
            <h3 style="margin: 0 0 10px 0; font-size: 18px; color: #ffdd44;">×§× ×™×•×ª ×‘×¡×™×‘×•×‘ ×–×”:</h3>
            <div id="purchaseList" style="font-size: 14px; line-height: 1.4;"></div>
        </div>
        <button id="shopContinue">×”××©×š</button>
    </div>
    <div id="victory">
        <h1>!× ×™×¦×—×•×Ÿ!</h1>
        <p>×”×©×œ××ª ××ª ×›×œ 20 ×”×©×œ×‘×™×!</p>
        <button id="playAgain">×©×—×§ ×©×•×‘</button>
    </div>
    <div id="gameOver">
        <h1>!××©×—×§ × ×’××¨</h1>
        <div id="gameOverStats">
            <p>×”×’×¢×ª ×œ×©×œ×‘: <span id="finalLevel">1</span></p>
            <p>×¡×”"×› ×”×¨×™×’×•×ª: <span id="finalKills">0</span></p>
            <p>×¡×”"×› ×›×¡×£ ×©× ×¦×‘×¨: <span id="finalMoney">0</span></p>
        </div>
        <button id="restartGame">×”×ª×—×œ ××—×“×©</button>
    </div>
    <div id="info">
        ×©×œ×‘: <span id="level">1</span><br>
        ×”×¨×™×’×•×ª: <span id="kills">0</span><br>
        ×›×¡×£: <span id="money">0</span><br>
        ×–××Ÿ: <span id="timer">70</span><br>
        ××ª×’×¨: <span id="challenge">×”×¨×•×’ 10 ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!</span>
    </div>

    <div id="controls">
        <div class="control-cluster dpad">
            <button id="up">â–²</button>
            <button id="left">â—€</button>
            <button id="right">â–¶</button>
            <button id="down">â–¼</button>
        </div>
        <div class="control-cluster actions">
            <button id="attack">âš”ï¸</button>
            <button id="place">ğŸ§±</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // --- Firebase: Initialize ---
        // const firebaseConfig = {
        //     apiKey: "YOUR_API_KEY",
        //     authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
        //     projectId: "YOUR_PROJECT_ID",
        // };
        const firebaseConfig = {
            apiKey: "AIzaSyBpm1I7DI8-iSMkvA4DqlE2_H0pnFEr10s",
            authDomain: "enemyblock1.firebaseapp.com",
            projectId: "enemyblock1",
            storageBucket: "enemyblock1.firebasestorage.app",
            messagingSenderId: "521820641402",
            appId: "1:521820641402:web:b4c9b771351e3f3c2a83c3",
            measurementId: "G-XPYHGZVV6Z"
        };
        if (firebase && firebase.apps && !firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }   
        const auth = firebase.auth();
        const db = firebase.firestore();
        // UI elements for auth/leaderboard
        const authStatusEl = document.getElementById('authStatus');
        const userBar = document.getElementById('userBar');
        const displayNameInput = document.getElementById('displayNameInput');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const registerBtn = document.getElementById('registerBtn');
        const loginBtn = document.getElementById('loginBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const leaderboardToggleBtn = document.getElementById('leaderboardToggle');
        const leaderboardPanel = document.getElementById('leaderboardPanel');
        const leaderboardList = document.getElementById('leaderboardList');
        const leaderboardCloseBtn = document.getElementById('leaderboardClose');

        function formatSeconds(sec) {
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m}:${String(s).padStart(2, '0')}`;
        }

        function updateUserBarVisibility() {
            if (!userBar) return;
            userBar.style.display = gameActive ? 'none' : 'flex';
        }

        async function loadLeaderboard() {
            try {
                leaderboardList.innerHTML = '<li>×˜×•×¢×Ÿ...</li>';
                const snap = await db.collection('users')
                    .orderBy('bestLevel', 'desc')
                    .orderBy('bestTimeSeconds', 'asc')
                    .limit(20)
                    .get();
                const currentUid = auth.currentUser ? auth.currentUser.uid : null;
                let html = '';
                let rank = 1;
                snap.forEach(doc => {
                    const d = doc.data();
                    const isYou = currentUid && doc.id === currentUid;
                    const name = d.displayName || d.email || '×©×—×§×Ÿ';
                    const time = (typeof d.bestTimeSeconds === 'number') ? formatSeconds(d.bestTimeSeconds) : '-';
                    html += `<li class=\"${isYou ? 'youRow' : ''}\">#${rank++} Â· ${name} â€” ×©×œ×‘ ${d.bestLevel || 0} Â· ×–××Ÿ ${time}</li>`;
                });
                leaderboardList.innerHTML = html || '<li>×¢×“×™×™×Ÿ ××™×Ÿ × ×ª×•× ×™×</li>';
            } catch (e) {
                console.error('Failed to load leaderboard', e);
                // If index missing, fall back to single orderBy and client sort
                if (e && (e.code === 'failed-precondition' || /index/i.test(String(e.message || '')))) {
                    try {
                        const snap = await db.collection('users')
                            .orderBy('bestLevel', 'desc')
                            .limit(50)
                            .get();
                        const currentUid = auth.currentUser ? auth.currentUser.uid : null;
                        const rows = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        rows.sort((a, b) => {
                            const levelDiff = (b.bestLevel || 0) - (a.bestLevel || 0);
                            if (levelDiff !== 0) return levelDiff;
                            const at = (typeof a.bestTimeSeconds === 'number') ? a.bestTimeSeconds : 999999;
                            const bt = (typeof b.bestTimeSeconds === 'number') ? b.bestTimeSeconds : 999999;
                            return at - bt;
                        });
                        let html = '';
                        rows.slice(0, 20).forEach((d, i) => {
                            const isYou = currentUid && d.id === currentUid;
                            const name = d.displayName || d.email || '×©×—×§×Ÿ';
                            const time = (typeof d.bestTimeSeconds === 'number') ? formatSeconds(d.bestTimeSeconds) : '-';
                            html += `<li class=\"${isYou ? 'youRow' : ''}\">#${i + 1} Â· ${name} â€” ×©×œ×‘ ${d.bestLevel || 0} Â· ×–××Ÿ ${time}</li>`;
                        });
                        leaderboardList.innerHTML = html || '<li>×¢×“×™×™×Ÿ ××™×Ÿ × ×ª×•× ×™×</li>';
                        const note = document.getElementById('leaderboardNote');
                        if (note) note.textContent = '×˜×¢×Ÿ ×œ×œ× ××™× ×“×§×¡ ××•×¨×›×‘. ××•××œ×¥ ×œ×™×¦×•×¨ ××™× ×“×§×¡: bestLevel (desc), bestTimeSeconds (asc).';
                        return;
                    } catch (e2) {
                        console.error('Fallback leaderboard load failed', e2);
                        if (e2 && e2.code === 'permission-denied') {
                            leaderboardList.innerHTML = '<li>××™×Ÿ ×”×¨×©××” ×œ×§×¨×•× × ×ª×•× ×™×. ×¢×“×›×Ÿ ×›×œ×œ×™ Firestore ×œ×§×¨×™××” ×- users.</li>';
                            return;
                        }
                    }
                }
                if (e && e.code === 'permission-denied') {
                    leaderboardList.innerHTML = '<li>××™×Ÿ ×”×¨×©××” ×œ×§×¨×•× × ×ª×•× ×™×. ×¢×“×›×Ÿ ×›×œ×œ×™ Firestore ×œ×§×¨×™××” ×- users.</li>';
                } else {
                    const msg = (e && e.message) ? String(e.message) : '×©×’×™××” ×œ× ×™×“×•×¢×”';
                    leaderboardList.innerHTML = `<li>×©×’×™××” ×‘×˜×¢×™× ×ª ×˜×‘×œ×ª ×”××•×‘×™×œ×™×</li><li style=\"font-size:12px;opacity:.8\">${msg}</li>`;
                }
            }
        }

        async function ensureUserDoc(user) {
            const ref = db.collection('users').doc(user.uid);
            const snap = await ref.get();
            if (!snap.exists) {
                await ref.set({
                    uid: user.uid,
                    email: user.email || null,
                    displayName: user.displayName || null,
                    bestLevel: 0,
                    bestTimeSeconds: 999999,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        }

        async function updateUserBest(finalLevel, totalSeconds) {
            try {
                const user = auth.currentUser;
                if (!user) return; // Not logged in
                const ref = db.collection('users').doc(user.uid);
                const snap = await ref.get();
                const data = snap.exists ? snap.data() : { bestLevel: 0, bestTimeSeconds: 999999 };
                const isBetter = (finalLevel > (data.bestLevel || 0)) ||
                                 (finalLevel === (data.bestLevel || 0) && totalSeconds < (data.bestTimeSeconds ?? 999999));
                const base = {
                    uid: user.uid,
                    email: user.email || null,
                    displayName: user.displayName || displayNameInput.value || null,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                if (!snap.exists) {
                    await ref.set({ ...base, bestLevel: finalLevel, bestTimeSeconds: totalSeconds, createdAt: firebase.firestore.FieldValue.serverTimestamp() });
                } else if (isBetter) {
                    await ref.update({ ...base, bestLevel: finalLevel, bestTimeSeconds: totalSeconds });
                } else {
                    await ref.update(base);
                }
                loadLeaderboard();
            } catch (e) {
                console.error('Failed to update best', e);
            }
        }

        auth.onAuthStateChanged(async (user) => {
            if (user) {
                authStatusEl.textContent = `××—×•×‘×¨ ×›- ${user.displayName || user.email}`;
                logoutBtn.style.display = '';
                loginBtn.style.display = 'none';
                registerBtn.style.display = 'none';
                await ensureUserDoc(user);
                loadLeaderboard();
            } else {
                authStatusEl.textContent = '×œ× ××—×•×‘×¨';
                logoutBtn.style.display = 'none';
                loginBtn.style.display = '';
                registerBtn.style.display = '';
                loadLeaderboard();
            }
        });

        registerBtn.addEventListener('click', async () => {
            try {
                const email = emailInput.value.trim();
                const pass = passwordInput.value;
                const displayName = displayNameInput.value.trim();
                if (!email || !pass) return;
                const cred = await auth.createUserWithEmailAndPassword(email, pass);
                if (displayName) {
                    await cred.user.updateProfile({ displayName });
                }
                await ensureUserDoc(cred.user);
            } catch (e) {
                console.error('Registration failed', e);
                alert('×©×’×™××” ×‘×”×¨×©××”: ' + (e.message || e));
            }
        });

        loginBtn.addEventListener('click', async () => {
            try {
                const email = emailInput.value.trim();
                const pass = passwordInput.value;
                if (!email || !pass) return;
                await auth.signInWithEmailAndPassword(email, pass);
            } catch (e) {
                console.error('Login failed', e);
                alert('×©×’×™××” ×‘×”×ª×—×‘×¨×•×ª: ' + (e.message || e));
            }
        });

        logoutBtn.addEventListener('click', async () => {
            try {
                await auth.signOut();
            } catch {}
        });

        leaderboardToggleBtn.addEventListener('click', () => {
            const isShown = leaderboardPanel.style.display === 'block';
            leaderboardPanel.style.display = isShown ? 'none' : 'block';
            if (!isShown) loadLeaderboard();
        });
        leaderboardCloseBtn?.addEventListener('click', () => {
            leaderboardPanel.style.display = 'none';
        });

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();
        window.addEventListener("resize", setCanvasSize);

        // Background images for different level ranges
        const backgroundImages = {
            bkg1: new Image(),
            bkg2: new Image(),
            bkg3: new Image(),
            bkg4: new Image()
        };
        
        // Player image
        const playerImage = new Image();
        playerImage.src = 'player.jpeg';
        playerImage.onload = () => console.log('player.jpeg loaded successfully');
        playerImage.onerror = () => console.error('Failed to load player.jpeg');
        
        // Red enemy image
        const redEnemyImage = new Image();
        redEnemyImage.src = 'red-enemy.jpeg';
        redEnemyImage.onload = () => console.log('red-enemy.jpeg loaded successfully');
        redEnemyImage.onerror = () => console.error('Failed to load red-enemy.jpeg');
        
        // Yellow enemy image
        const yellowEnemyImage = new Image();
        yellowEnemyImage.src = 'yellow-enemy.jpeg';
        yellowEnemyImage.onload = () => console.log('yellow-enemy.jpeg loaded successfully');
        yellowEnemyImage.onerror = () => console.error('Failed to load yellow-enemy.jpeg');
        
        // Boss images
        const boss1Image = new Image();
        boss1Image.src = 'boss1.jpeg';
        boss1Image.onload = () => console.log('boss1.jpeg loaded successfully');
        boss1Image.onerror = () => console.error('Failed to load boss1.jpeg');
        
        const boss2Image = new Image();
        boss2Image.src = 'boss2.jpeg';
        boss2Image.onload = () => console.log('boss2.jpeg loaded successfully');
        boss2Image.onerror = () => console.error('Failed to load boss2.jpeg');
        
        const boss3Image = new Image();
        boss3Image.src = 'boss3.jpeg';
        boss3Image.onload = () => console.log('boss3.jpeg loaded successfully');
        boss3Image.onerror = () => console.error('Failed to load boss3.jpeg');
        
        const boss4Image = new Image();
        boss4Image.src = 'boss4.jpeg';
        boss4Image.onload = () => console.log('boss4.jpeg loaded successfully');
        boss4Image.onerror = () => console.error('Failed to load boss4.jpeg');
        
        // Mini-boss image
        const miniBossImage = new Image();
        miniBossImage.src = 'mini-boss.jpeg';
        miniBossImage.onload = () => console.log('mini-boss.jpeg loaded successfully');
        miniBossImage.onerror = () => console.error('Failed to load mini-boss.jpeg');
        
        // Load background images
        backgroundImages.bkg1.src = 'bkg1.jpeg';
        backgroundImages.bkg2.src = 'bkg2.jpeg';
        backgroundImages.bkg3.src = 'bkg3.jpeg';
        backgroundImages.bkg4.src = 'bkg4.jpeg';
        
        // Add load event listeners for debugging
        backgroundImages.bkg1.onload = () => console.log('bkg1.jpeg loaded successfully');
        backgroundImages.bkg2.onload = () => console.log('bkg2.jpeg loaded successfully');
        backgroundImages.bkg3.onload = () => console.log('bkg3.jpeg loaded successfully');
        backgroundImages.bkg4.onload = () => console.log('bkg4.jpeg loaded successfully');
        backgroundImages.bkg1.onerror = () => console.error('Failed to load bkg1.jpeg');
        backgroundImages.bkg2.onerror = () => console.error('Failed to load bkg2.jpeg');
        backgroundImages.bkg3.onerror = () => console.error('Failed to load bkg3.jpeg');
        backgroundImages.bkg4.onerror = () => console.error('Failed to load bkg4.jpeg');
        
        // Function to get appropriate background for current level
        function getCurrentBackground() {
            if (level >= 1 && level <= 5) {
                return backgroundImages.bkg1;
            } else if (level >= 6 && level <= 10) {
                return backgroundImages.bkg2;
            } else if (level >= 11 && level <= 15) {
                return backgroundImages.bkg3;
            } else if (level >= 16 && level <= 20) {
                return backgroundImages.bkg4;
            }
            // Default fallback
            return backgroundImages.bkg1;
        }
        
        // Track current background to detect changes
        let currentBackgroundName = '';
        
        // Function to draw background
        function drawBackground() {
            const bgImage = getCurrentBackground();
                       
            if (bgImage.complete) {
                // Draw background image to fill entire canvas
                ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
            } else {
                // Fallback to solid color if image not loaded
                ctx.fillStyle = "#87ceeb";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        const welcomeScreen = document.getElementById("welcomeScreen");
        const startGameButton = document.getElementById("startGame");
        const heartsDisplay = document.querySelector(".hearts");
        const shopElement = document.getElementById("shop");
        const victoryElement = document.getElementById("victory");
        const gameOverElement = document.getElementById("gameOver");
        const playAgainButton = document.getElementById("playAgain");
        const restartGameButton = document.getElementById("restartGame");
        const finalLevelDisplay = document.getElementById("finalLevel");
        const finalKillsDisplay = document.getElementById("finalKills");
        const finalMoneyDisplay = document.getElementById("finalMoney");
        const buySpeedButton = document.getElementById("buySpeed");
        const buyRangeButton = document.getElementById("buyRange");
        const buyMoneyButton = document.getElementById("buyMoney");
        const buyHealthButton = document.getElementById("buyHealth");
        const buyTimeButton = document.getElementById("buyTime");
        const shopContinueButton = document.getElementById("shopContinue");
        const purchaseHistoryDiv = document.getElementById("purchaseHistory");
        const purchaseListDiv = document.getElementById("purchaseList");
        const levelDisplay = document.getElementById("level");
        const killsDisplay = document.getElementById("kills");
        const moneyDisplay = document.getElementById("money");
        const timerDisplay = document.getElementById("timer");
        const challengeDisplay = document.getElementById("challenge");
        const infoDisplay = document.getElementById("info");

        const upButton = document.getElementById("up");
        const downButton = document.getElementById("down");
        const leftButton = document.getElementById("left");
        const rightButton = document.getElementById("right");
        const placeButton = document.getElementById("place");
        const attackButton = document.getElementById("attack");

        let level = 1;
        let kills = 0;
        let weaponDamage = 50;
        let money = 0;
        let enemySpawnInterval = 1000;
        let enemiesToKillForLevel = 10;
        let playerSpeed = 5;
        let attackRange = 50;
        let moneyPerKill = 5;
        let gameActive = false;  // Start with game inactive
        let spawnEnemiesEnabled = false;
        let gameStarted = false;
        let bossKilled = false;
        let baseLevelTime = 70;  // Base time for each level (can be upgraded)
        let levelTimeRemaining = 70;
        let levelStartTime = Date.now();
        let gameSessionStart = 0; // Track total time from session start
        let cumulativeCompletedLevelSeconds = 0; // Sum of durations for fully completed levels only
        let lastLevelEndTime = 0; // Timestamp when level completion occurred (before shop)
        let maxHearts = 3;  // Maximum hearts (can be upgraded in shop)
        let attackStartTime = 0;
        let attackEnded = false;
        let attackDuration = 3000;  // 3 seconds of attack (upgradeable)

        // --- Google Analytics Event Tracking ---
        function trackEvent(eventName, eventParams = {}) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, eventParams);
            } else {
                console.log(`GA Event (gtag not found): ${eventName}`, eventParams);
            }
        }
        // ------------------------------------

        // --- Level-based Damage System ---
        function getEnemyProjectileDamage() {
            if (level >= 20) return 5;      // Level 20: 5 damage
            if (level >= 16) return 3;      // Level 16-19: 3 damage  
            if (level >= 11) return 2;      // Level 11-15: 2 damage
            return 1;                       // Level 1-10: 1 damage
        }
        // ---------------------------------

        const player = {
            x: 50,
            y: canvas.height - 100,
            width: 30,
            height: 30,
            color: "green",
            speed: playerSpeed,
            hearts: 3,
            inventory: [],
            rotation: 0,  // Player facing direction in degrees (0=right, 90=down, 270=up)
            facingLeft: false  // Track if player is facing left for horizontal mirroring
        };

        const hills = [];
        for (let i = 0; i < 10; i++) {
            hills.push({
                x: Math.random() * (canvas.width - 50),
                y: Math.random() * (canvas.height - 50),
                width: 50,
                height: 50,
                color: "brown",
                resources: 5
            });
        }

        const enemies = [];
        const projectiles = [];
        const fireballs = [];
        const poisonBottles = [];
        const miniBosses = [];
        const builtBlocks = [];
        let lastFortifyTime = 0;
        const fortifyInterval = 5000;

        function spawnEnemies() {
            // Check if this is a boss level (5, 10, 15, 20)
            const isBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
            
            // Always spawn regular enemies
            for (let i = 0; i < level * 2; i++) {
                const enemyLives = level >= 11 ? 2 : 1;  // 2 lives starting from level 11
                enemies.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 30,
                    height: 30,
                    color: Math.random() > 0.5 ? "yellow" : "red",
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    health: 10 + level * 2,
                    lives: enemyLives,
                    maxLives: enemyLives,
                    hitFlash: 0,  // For hit animation
                    protectionEndTime: 0,  // For protection after being hit
                    isFortified: false,
                    fortifyColor: "black",
                    isBoss: false
                });
            }
            
            // Additionally spawn boss on boss levels
            if (isBossLevel) {
                // Determine boss lives based on level
                let bossLives;
                if (level === 5) bossLives = 2;
                else if (level === 10) bossLives = 4;
                else if (level === 15) bossLives = 7;
                else if (level === 20) bossLives = 10;
                
                enemies.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 45,  // Slightly larger
                    height: 45,
                    color: "orange",
                    dx: Math.random() > 0.5 ? 0.8 : -0.8,  // Slower than normal enemies
                    dy: Math.random() > 0.5 ? 0.8 : -0.8,
                    health: 50 + level * 5,  // Much more health
                    isBoss: true,
                    lastShot: Date.now(),  // Initialize with current time
                    lastFireballShot: Date.now() - 8000,  // Initialize fireball shot time (start with 2s delay for testing)
                    lastPoisonShot: Date.now() - 8000,  // Initialize poison shot time (start with 2s delay for testing)
                    lastMiniBossSpawn: Date.now() - 8000,  // Initialize mini-boss spawn time (start with 2s delay for testing)
                    miniBossSpawnCount: 0,  // Track how many times mini-bosses have been spawned
                    lives: bossLives,
                    maxLives: bossLives,
                    hitFlash: 0,  // For hit animation
                    protectionEndTime: 0  // When protection dome expires
                });
                if (level === 10) {
                    console.log("Level 10 boss created with fireball capability!");
                }
                if (level === 15) {
                    console.log("Level 15 boss created with poison bottle capability!");
                }
                if (level === 20) {
                    console.log("Level 20 boss created with mini-boss spawning capability!");
                }
                bossKilled = false;
            }
        }
        spawnEnemies();

        function reinforceEnemies() {
            enemies.forEach(enemy => {
                enemy.health += 2;
                enemy.dx *= 1.1;
                enemy.dy *= 1.1;
            });
        }

        function spawnNewEnemy() {
            // Continue spawning regular enemies even on boss levels
            if (spawnEnemiesEnabled) {
                const enemyColor = Math.random() > 0.5 ? "yellow" : "red";
                const enemyLives = level >= 11 ? 2 : 1;  // 2 lives starting from level 11
                const newEnemy = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    width: 30,
                    height: 30,
                    color: enemyColor,
                    dx: Math.random() > 0.5 ? 1 : -1,
                    dy: Math.random() > 0.5 ? 1 : -1,
                    health: 10 + level * 2,
                    lives: enemyLives,
                    maxLives: enemyLives,
                    hitFlash: 0,  // For hit animation
                    protectionEndTime: 0,  // For protection after being hit
                    isBoss: false
                };
                enemies.push(newEnemy);
            }
        }
        setInterval(() => {
            reinforceEnemies();
            spawnNewEnemy();
        }, 4000);

        const keys = {};
        function updateKeyStateFromCode(e, isDown) {
            // Normalize by physical key to avoid locale issues (e.g., Hebrew layout)
            switch (e.code) {
                case 'KeyD': keys['d'] = isDown; break;
                case 'KeyG': keys['g'] = isDown; break;
                case 'Space': keys[' '] = isDown; break;
                case 'ArrowUp': keys['arrowup'] = isDown; break;
                case 'ArrowDown': keys['arrowdown'] = isDown; break;
                case 'ArrowLeft': keys['arrowleft'] = isDown; break;
                case 'ArrowRight': keys['arrowright'] = isDown; break;
            }
        }
        window.addEventListener("keydown", (e) => {
            keys[e.key.toLowerCase()] = true; // keep legacy map
            updateKeyStateFromCode(e, true);
            if (e.key === 'Enter') {
                resetGame();
            }
            if (e.key === '0') {
                if (!gameActive) {
                    nextLevel();
                }
            }
        });
        window.addEventListener("keyup", (e) => {
            keys[e.key.toLowerCase()] = false; // keep legacy map
            updateKeyStateFromCode(e, false);
        });

        function handleControl(button, key) {
            function press(e) {
                e.preventDefault();
                keys[key] = true;
            }
            function release(e) {
                e.preventDefault();
                keys[key] = false;
            }
            if (button) {
                button.addEventListener("mousedown", press);
                button.addEventListener("mouseup", release);
                button.addEventListener("mouseleave", release);
                button.addEventListener("touchstart", press, { passive: false });
                button.addEventListener("touchend", release);
                button.addEventListener("touchcancel", release);
            }
        }

        handleControl(upButton, "arrowup");
        handleControl(downButton, "arrowdown");
        handleControl(leftButton, "arrowleft");
        handleControl(rightButton, "arrowright");
        handleControl(placeButton, " ");
        handleControl(attackButton, "d");

        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }

        function movePlayer() {
            let newX = player.x;
            let newY = player.y;

            // Track movement and update rotation/facing direction
            let moved = false;
            if (keys["arrowright"]) {
                newX += player.speed;
                player.rotation = 0;    // Face right
                player.facingLeft = false;
                moved = true;
            }
            if (keys["arrowleft"]) {
                newX -= player.speed;
                player.rotation = 0;    // Same rotation as right, but will be mirrored
                player.facingLeft = true;
                moved = true;
            }
            if (keys["arrowup"]) {
                newY -= player.speed;
                player.rotation = 270;  // Face up
                player.facingLeft = false;
                moved = true;
            }
            if (keys["arrowdown"]) {
                newY += player.speed;
                player.rotation = 90;   // Face down
                player.facingLeft = false;
                moved = true;
            }

            let collision = false;
            for (let hill of hills) {
                if (checkCollision({...player, x: newX, y: newY}, hill)) {
                    collision = true;
                    break;
                }
            }
            if (!collision) {
                for (let block of builtBlocks) {
                    if (checkCollision({...player, x: newX, y: newY}, block)) {
                        collision = true;
                        break;
                    }
                }
            }

            if (!collision) {
                player.x = newX;
                player.y = newY;
            }

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
        }

        function mineHills() {
            hills.forEach((hill, index) => {
                if (
                    player.x < hill.x + hill.width &&
                    player.x + player.width > hill.x &&
                    player.y < hill.y + hill.height &&
                    player.y + player.height > hill.y &&
                    keys["g"]
                ) {
                    player.inventory.push({ color: hill.color });
                    player.inventory.push({ color: hill.color });
                    hill.resources--;
                    if (hill.resources <= 0) {
                        hills.splice(index, 1);
                        player.inventory.push({ color: hill.color });
                        player.inventory.push({ color: hill.color });
                    }
                }
            });
        }

        function placeBlock() {
            if (keys[" "] && player.inventory.length > 0) {
                const block = player.inventory.pop();
                const newBlock = {
                    x: player.x + 40,
                    y: player.y,
                    width: 30,
                    height: 30,
                    color: block.color
                };

                let collision = false;
                for (let builtBlock of builtBlocks) {
                    if (checkCollision(newBlock, builtBlock)) {
                        collision = true;
                        break;
                    }
                }
                for (let hill of hills) {
                    if (checkCollision(newBlock, hill)) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    builtBlocks.push(newBlock);
                }
            }
        }

        function moveEnemies() {
            enemies.forEach(enemy => {
                let newX = enemy.x + enemy.dx;
                let newY = enemy.y + enemy.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision({...enemy, x: newX, y: newY}, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision({...enemy, x: newX, y: newY}, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    enemy.x = newX;
                    enemy.y = newY;
                }
                else{
                    enemy.dx *= -1;
                    enemy.dy *= -1;
                }

                if (enemy.x <= 0 || enemy.x + enemy.width >= canvas.width) enemy.dx *= -1;
                if (enemy.y <= 0 || enemy.y + enemy.height >= canvas.height) enemy.dy *= -1;

                // Boss shooting in 8 directions
                if (enemy.isBoss && Date.now() - enemy.lastShot > 1500) {
                    enemy.lastShot = Date.now();
                    // 8 directions: N, NE, E, SE, S, SW, W, NW
                    const directions = [
                        {dx: 0, dy: -2},   // North
                        {dx: 1.4, dy: -1.4}, // Northeast
                        {dx: 2, dy: 0},    // East
                        {dx: 1.4, dy: 1.4},  // Southeast
                        {dx: 0, dy: 2},    // South
                        {dx: -1.4, dy: 1.4}, // Southwest
                        {dx: -2, dy: 0},   // West
                        {dx: -1.4, dy: -1.4} // Northwest
                    ];
                    
                    directions.forEach(dir => {
                        let projectileCollision = false;
                        const newProjectilePos = {
                            x: enemy.x + enemy.width/2 + dir.dx * 10,
                            y: enemy.y + enemy.height/2 + dir.dy * 10,
                            width: 5,
                            height: 5
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newProjectilePos, hill)) {
                                projectileCollision = true;
                                break;
                            }
                        }
                        if (!projectileCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newProjectilePos, block)) {
                                    projectileCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!projectileCollision) {
                            projectiles.push({ 
                                x: enemy.x + enemy.width/2, 
                                y: enemy.y + enemy.height/2, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 5,
                                height: 5
                            });
                        }
                    });
                }
                
                // Level 10 boss fireball shooting (every 10 seconds, 4 directions)
                if (enemy.isBoss && level === 10 && Date.now() - enemy.lastFireballShot > 10000) {
                    console.log("Level 10 boss firing fireballs!");
                    enemy.lastFireballShot = Date.now();
                    // 4 cardinal directions for fireballs
                    const fireballDirections = [
                        {dx: 0, dy: -1.5},  // North
                        {dx: 1.5, dy: 0},   // East
                        {dx: 0, dy: 1.5},   // South
                        {dx: -1.5, dy: 0}   // West
                    ];
                    
                    fireballDirections.forEach(dir => {
                        let fireballCollision = false;
                        const newFireballPos = {
                            x: enemy.x + enemy.width/2 + dir.dx * 10,
                            y: enemy.y + enemy.height/2 + dir.dy * 10,
                            width: 40,  // Much larger - almost boss size (boss is 45x45)
                            height: 40
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newFireballPos, hill)) {
                                fireballCollision = true;
                                break;
                            }
                        }
                        if (!fireballCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newFireballPos, block)) {
                                    fireballCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!fireballCollision) {
                            console.log("Creating large fireball in direction:", dir);
                            fireballs.push({ 
                                x: enemy.x + enemy.width/2 - 20, // Center the large fireball
                                y: enemy.y + enemy.height/2 - 20, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 40,  // Much larger - almost boss size (boss is 45x45)
                                height: 40
                            });
                        }
                    });
                }
                
                // Level 15 boss poison bottle shooting (every 10 seconds, smart tracking, only 1 at a time)
                if (enemy.isBoss && level === 15 && Date.now() - enemy.lastPoisonShot > 10000 && poisonBottles.length === 0) {
                    console.log("Level 15 boss firing poison bottle!");
                    enemy.lastPoisonShot = Date.now();
                    
                    let poisonCollision = false;
                    const newPoisonPos = {
                        x: enemy.x + enemy.width/2,
                        y: enemy.y + enemy.height/2,
                        width: 15,
                        height: 15
                    };
                    
                    // Check initial collision
                    for (let hill of hills) {
                        if(checkCollision(newPoisonPos, hill)) {
                            poisonCollision = true;
                            break;
                        }
                    }
                    if (!poisonCollision) {
                        for (let block of builtBlocks) {
                            if(checkCollision(newPoisonPos, block)) {
                                poisonCollision = true;
                                break;
                            }
                        }
                    }
                    
                    if (!poisonCollision) {
                        console.log("Creating poison bottle with player tracking! (Only 1 allowed at a time)");
                        poisonBottles.push({ 
                            x: enemy.x + enemy.width/2, 
                            y: enemy.y + enemy.height/2, 
                            targetX: player.x + player.width/2,
                            targetY: player.y + player.height/2,
                            speed: 4,  // Faster poison bottles
                            width: 15,
                            height: 15,
                            updateTargetTime: Date.now()
                        });
                    }
                }
                
                // Level 20 boss mini-boss spawning (every 10 seconds, increasing number each time)
                if (enemy.isBoss && level === 20 && Date.now() - enemy.lastMiniBossSpawn > 10000) {
                    enemy.miniBossSpawnCount++;  // Increment spawn count
                    const miniBossesToSpawn = 1 + enemy.miniBossSpawnCount;  // 2 first time, 3 second time, 4 third time, etc.
                    console.log(`Level 20 boss spawning ${miniBossesToSpawn} mini-bosses! (spawn #${enemy.miniBossSpawnCount})`);
                    enemy.lastMiniBossSpawn = Date.now();
                    
                    // Spawn increasing number of mini-bosses
                    for (let i = 0; i < miniBossesToSpawn; i++) {
                        let spawnX, spawnY;
                        let attempts = 0;
                        
                        // Try to find a good spawn position (not colliding with obstacles)
                        do {
                            spawnX = Math.random() * (canvas.width - 30);
                            spawnY = Math.random() * (canvas.height - 30);
                            attempts++;
                        } while (attempts < 10); // Limit attempts to prevent infinite loop
                        
                        console.log(`Creating mini-boss ${i + 1} at position (${spawnX}, ${spawnY})`);
                        miniBosses.push({
                            x: spawnX,
                            y: spawnY,
                            width: 25,  // Smaller than main boss (45)
                            height: 25,
                            color: "purple",  // Different color to distinguish from main boss
                            dx: Math.random() > 0.5 ? 1.5 : -1.5,  // Faster than main boss (0.8)
                            dy: Math.random() > 0.5 ? 1.5 : -1.5,
                            health: 30,  // Less health than main boss
                            isBoss: false,  // Not a main boss
                            isMiniBoss: true,
                            lives: 3,  // Increased from 2 to 3 lives
                            maxLives: 3,
                            hitFlash: 0,
                            protectionEndTime: 0,
                            lastShot: Date.now()
                        });
                    }
                }
                // Normal yellow enemy shooting
                else if (enemy.color === "yellow" && Math.random() < 0.01) {
                    let projectileCollision = false;
                    const newProjectileX = enemy.x - 2;
                    for (let hill of hills)
                    {
                        if(checkCollision({x: newProjectileX, y: enemy.y, width: 5, height: 5}, hill))
                        {
                            projectileCollision = true;
                            break;
                        }
                    }
                    if (!projectileCollision)
                    {
                        for (let block of builtBlocks)
                        {
                            if(checkCollision({x: newProjectileX, y: enemy.y, width: 5, height: 5}, block))
                            {
                                projectileCollision = true;
                                break;
                            }
                        }
                    }
                    if (!projectileCollision)
                    {
                        projectiles.push({ x: enemy.x, y: enemy.y, dx: -2, dy: 0, width: 5, height: 5 });
                    }
                }
            });
        }

        function moveProjectiles() {
            projectiles.forEach((projectile, index) => {
                projectile.x += projectile.dx;
                projectile.y += projectile.dy || 0;  // Handle dy for boss projectiles

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision(projectile, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision(projectile, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (collision) {
                    projectiles.splice(index, 1);
                    return;
                }

                if (projectile.x < 0 || projectile.x > canvas.width || 
                    projectile.y < 0 || projectile.y > canvas.height) {
                    projectiles.splice(index, 1);
                }

                if (
                    projectile.x < player.x + player.width &&
                    projectile.x + (projectile.width || 5) > player.x &&
                    projectile.y < player.y + player.height &&
                    projectile.y + (projectile.height || 5) > player.y
                ) {
                    const damage = getEnemyProjectileDamage();
                    player.hearts -= damage;
                    projectiles.splice(index, 1);
                    console.log(`Projectile hit! Damage: ${damage}, Hearts left: ${player.hearts}`);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                        showGameOver("× ×’××¨×• ×”×—×™×™×!");
                    }
                }
            });
        }

        function moveFireballs() {
            if (fireballs.length > 0) {
                console.log("Moving", fireballs.length, "fireballs");
            }
            fireballs.forEach((fireball, index) => {
                fireball.x += fireball.dx;
                fireball.y += fireball.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision(fireball, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision(fireball, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (collision) {
                    fireballs.splice(index, 1);
                    return;
                }

                if (fireball.x < 0 || fireball.x > canvas.width || 
                    fireball.y < 0 || fireball.y > canvas.height) {
                    fireballs.splice(index, 1);
                }

                // Fireball collision with player - deals level-based damage
                if (
                    fireball.x < player.x + player.width &&
                    fireball.x + fireball.width > player.x &&
                    fireball.y < player.y + player.height &&
                    fireball.y + fireball.height > player.y
                ) {
                    const damage = getEnemyProjectileDamage();
                    player.hearts -= damage;
                    fireballs.splice(index, 1);
                    console.log(`Fireball hit! Damage: ${damage}, Hearts left: ${player.hearts}`);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                        showGameOver("× ×’××¨×• ×”×—×™×™×!");
                    }
                }
            });
        }

        function movePoisonBottles() {
            if (poisonBottles.length > 0) {
                console.log("Moving", poisonBottles.length, "poison bottles");
            }
            poisonBottles.forEach((poison, index) => {
                // Update target position every 500ms for smart tracking
                if (Date.now() - poison.updateTargetTime > 500) {
                    poison.targetX = player.x + player.width/2;
                    poison.targetY = player.y + player.height/2;
                    poison.updateTargetTime = Date.now();
                }
                
                // Calculate direction towards target
                const dx = poison.targetX - poison.x;
                const dy = poison.targetY - poison.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 0) {
                    // Normalize direction and apply speed
                    poison.x += (dx / distance) * poison.speed;
                    poison.y += (dy / distance) * poison.speed;
                }

                // Check collision with hills (rocks) - destroy rock but continue
                for (let h = hills.length - 1; h >= 0; h--) {
                    const hill = hills[h];
                    if (checkCollision(poison, hill)) {
                        console.log("Poison bottle destroyed a rock!");
                        hills.splice(h, 1);  // Destroy the rock
                        // Poison bottle continues moving, doesn't get destroyed
                    }
                }
                
                // Check collision with built blocks (walls) - poison bottle gets destroyed
                let wallCollision = false;
                for (let block of builtBlocks) {
                    if (checkCollision(poison, block)) {
                        wallCollision = true;
                        break;
                    }
                }

                if (wallCollision) {
                    console.log("Poison bottle hit wall and was destroyed!");
                    poisonBottles.splice(index, 1);
                    return;
                }

                // Remove if off screen
                if (poison.x < -20 || poison.x > canvas.width + 20 || 
                    poison.y < -20 || poison.y > canvas.height + 20) {
                    console.log("Poison bottle went off screen and was removed");
                    poisonBottles.splice(index, 1);
                    return;
                }

                // Poison bottle collision with player - deals 2 damage and heavily reduces stats
                if (checkCollision(poison, player)) {
                    console.log("Poison bottle hit player! Heavily reducing stats...");
                    player.hearts -= 2;  // Reduce 2 lives
                    attackRange = Math.max(10, attackRange - 20);  // Reduce 20 range (minimum 10)
                    player.speed = Math.max(1, player.speed - 1);  // Reduce 1 speed (minimum 1)
                    playerSpeed = player.speed;  // Update player speed
                    // Update currentValues to reflect the permanently reduced stats
                    currentValues.range = attackRange;
                    currentValues.speed = player.speed;
                    poisonBottles.splice(index, 1);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                    }
                }
            });
        }

        function moveMiniBosses() {
            if (miniBosses.length > 0) {
                console.log("Moving", miniBosses.length, "mini-bosses");
            }
            miniBosses.forEach((miniBoss, index) => {
                // Move mini-boss
                let newX = miniBoss.x + miniBoss.dx;
                let newY = miniBoss.y + miniBoss.dy;

                let collision = false;
                for (let hill of hills) {
                    if (checkCollision({...miniBoss, x: newX, y: newY}, hill)) {
                        collision = true;
                        break;
                    }
                }
                if (!collision) {
                    for (let block of builtBlocks) {
                        if (checkCollision({...miniBoss, x: newX, y: newY}, block)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    miniBoss.x = newX;
                    miniBoss.y = newY;
                } else {
                    miniBoss.dx *= -1;
                    miniBoss.dy *= -1;
                }

                // Bounce off walls
                if (miniBoss.x <= 0 || miniBoss.x + miniBoss.width >= canvas.width) miniBoss.dx *= -1;
                if (miniBoss.y <= 0 || miniBoss.y + miniBoss.height >= canvas.height) miniBoss.dy *= -1;

                // Mini-boss shooting (faster than normal enemies)
                if (Date.now() - miniBoss.lastShot > 800) {  // Shoot every 0.8 seconds
                    miniBoss.lastShot = Date.now();
                    // 4 directions: N, E, S, W
                    const directions = [
                        {dx: 0, dy: -2.5},   // North
                        {dx: 2.5, dy: 0},    // East
                        {dx: 0, dy: 2.5},    // South
                        {dx: -2.5, dy: 0}    // West
                    ];
                    
                    directions.forEach(dir => {
                        let projectileCollision = false;
                        const newProjectilePos = {
                            x: miniBoss.x + miniBoss.width/2 + dir.dx * 10,
                            y: miniBoss.y + miniBoss.height/2 + dir.dy * 10,
                            width: 5,
                            height: 5
                        };
                        
                        for (let hill of hills) {
                            if(checkCollision(newProjectilePos, hill)) {
                                projectileCollision = true;
                                break;
                            }
                        }
                        if (!projectileCollision) {
                            for (let block of builtBlocks) {
                                if(checkCollision(newProjectilePos, block)) {
                                    projectileCollision = true;
                                    break;
                                }
                            }
                        }
                        if (!projectileCollision) {
                            projectiles.push({ 
                                x: miniBoss.x + miniBoss.width/2, 
                                y: miniBoss.y + miniBoss.height/2, 
                                dx: dir.dx, 
                                dy: dir.dy,
                                width: 5,
                                height: 5
                            });
                        }
                    });
                }

                // Check collision with player (mini-bosses deal damage on contact)
                if (checkCollision(miniBoss, player)) {
                    const damage = getEnemyProjectileDamage();
                    player.hearts -= damage;
                    miniBosses.splice(index, 1);
                    console.log(`Mini-boss hit player! Damage: ${damage}, Hearts left: ${player.hearts}`);
                    if (player.hearts <= 0) {
                        player.hearts = 0;
                        showGameOver("× ×’××¨×• ×”×—×™×™×!");
                    }
                }
            });
        }

        function attackEnemies() {
            const currentTime = Date.now();
            
            // Check if attack button is pressed
            if (keys["d"]) {
                // If attack just started, record start time
                if (attackStartTime === 0 && !attackEnded) {
                    attackStartTime = currentTime;
                }
                
                // Check if attack duration has been exceeded
                if (attackStartTime > 0 && currentTime - attackStartTime > attackDuration) {
                    // Stop attacking after 3 seconds
                    attackEnded = true;
                    attackStartTime = 0;
                }
                
                // Only attack if within attack duration and not ended
                if (attackStartTime > 0 && !attackEnded) {
                    performAttack();
                }
            } else {
                // Reset when button is released
                attackStartTime = 0;
                attackEnded = false;
            }
        }

        function performAttack() {
            let targetIndex = -1;
            let closestDistance = Infinity;
                enemies.forEach((enemy, index) => {
                    const distance = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    if (distance < closestDistance && distance < attackRange) {
                        closestDistance = distance;
                        targetIndex = index;
                    }
                });

                if (targetIndex !== -1) {
                    const hitEnemy = enemies[targetIndex];
                    
                    if (hitEnemy.isBoss) {
                        // Check if boss is currently protected
                        if (Date.now() < hitEnemy.protectionEndTime) {
                            // Boss is protected, cannot be hit
                            return;
                        }
                        
                        hitEnemy.lives--;
                        hitEnemy.hitFlash = Date.now();  // Start hit flash animation
                        hitEnemy.protectionEndTime = Date.now() + 3000;  // 3 seconds of protection
                        
                        if (hitEnemy.lives <= 0) {
                            enemies.splice(targetIndex, 1);
                            kills += 5;  // Boss gives 5 kills
                            money += 10; // Boss gives 10 money
                            bossKilled = true;
                            trackEvent('boss_defeated', { level: level }); // GA Event
                        }
                    } else {
                        // Handle regular enemies with lives system (level 11+)
                        if (hitEnemy.lives && hitEnemy.lives > 1) {
                            // Check if enemy is currently protected
                            if (Date.now() < hitEnemy.protectionEndTime) {
                                // Enemy is protected, cannot be hit
                                return;
                            }
                            
                            hitEnemy.lives--;
                            hitEnemy.hitFlash = Date.now();  // Start hit flash animation
                            hitEnemy.protectionEndTime = Date.now() + 1000;  // 1 second of protection (shorter than boss)
                            console.log(`Enemy hit! Lives remaining: ${hitEnemy.lives}`);
                        } else {
                            // Enemy dies (either has 1 life originally or lost all lives)
                            enemies.splice(targetIndex, 1);
                            kills++;
                            money += moneyPerKill;
                            console.log("Enemy killed!");
                        }
                    }
                }

                // Check for mini-boss attacks
                let miniBossTargetIndex = -1;
                let miniBossClosestDistance = Infinity;
                miniBosses.forEach((miniBoss, index) => {
                    const distance = Math.hypot(player.x - miniBoss.x, player.y - miniBoss.y);
                    if (distance < miniBossClosestDistance && distance < attackRange) {
                        miniBossClosestDistance = distance;
                        miniBossTargetIndex = index;
                    }
                });

                if (miniBossTargetIndex !== -1) {
                    const hitMiniBoss = miniBosses[miniBossTargetIndex];
                    
                    // Check if mini-boss is currently protected
                    if (Date.now() < hitMiniBoss.protectionEndTime) {
                        // Mini-boss is protected, cannot be hit
                        return;
                    }
                    
                    hitMiniBoss.lives--;
                    hitMiniBoss.hitFlash = Date.now();  // Start hit flash animation
                    hitMiniBoss.protectionEndTime = Date.now() + 1500;  // 1.5 seconds of protection
                    
                    if (hitMiniBoss.lives <= 0) {
                        miniBosses.splice(miniBossTargetIndex, 1);
                        kills += 2;  // Mini-boss gives 2 kills
                        money += 8;  // Mini-boss gives 8 money
                        console.log("Mini-boss defeated!");
                    }
                }

                for (let i = builtBlocks.length - 1; i >= 0; i--) {
                    const block = builtBlocks[i];
                    const distance = Math.hypot(player.x - block.x, player.y - block.y);
                    if (distance < attackRange) {
                        builtBlocks.splice(i, 1);
                        console.log("Block removed!");
                        break;
                    }
                }

                hills.forEach((hill, index) => {
                    const distance = Math.hypot(player.x - hill.x, player.y - hill.y);
                    if (distance < attackRange) {
                        player.inventory.push({ color: hill.color });
                        player.inventory.push({ color: hill.color });
                        hill.resources--;
                        if (hill.resources <= 0) {
                            hills.splice(index, 1);
                            player.inventory.push({ color: hill.color });
                            player.inventory.push({ color: hill.color });
                        }
                    }
                });
        }

        function advanceLevel() {
            // Duration of the level that just ended
            const prevLevelDurationSeconds = Math.max(0, Math.floor((Date.now() - levelStartTime) / 1000));
            level++;
            levelDisplay.textContent = level;
            trackEvent('level_complete', { level: level }); // GA Event
            
            // Check for victory condition after completing level 20
            if (level > 20) {
                gameActive = false;
                spawnEnemiesEnabled = false;
                shopElement.style.display = "none";
                // Submit leaderboard time as sum of completed levels ONLY (exclude level 20)
                const totalSeconds = cumulativeCompletedLevelSeconds;
                updateUserBest(20, totalSeconds);
                victoryElement.style.display = "flex";
                trackEvent('victory'); // GA Event
                return;
            }
            
            // Add the just-completed level duration to the cumulative sum (only for non-victory levels)
            cumulativeCompletedLevelSeconds += prevLevelDurationSeconds;

            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            attackEnemies()
            kills = 0;
            killsDisplay.textContent = kills;
            enemiesToKillForLevel += 5;
            
            // Update challenge text based on level type
            const nextIsBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
            if (nextIsBossLevel) {
                challengeDisplay.textContent = "×”×¨×•×’ ××ª ×”×‘×•×¡ ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!";
            } else {
                challengeDisplay.textContent = `×”×¨×•×’ ${enemiesToKillForLevel} ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!`;
            }
            
            enemySpawnInterval = Math.max(100, enemySpawnInterval - 100);
            gameActive = true;
            updateUserBarVisibility();
            shopElement.style.display = "none";

            player.x = 50;
            player.y = canvas.height - 100;
            player.hearts = maxHearts;  // Use upgraded max hearts
            currentValues.health = maxHearts;  // Keep currentValues in sync
            player.facingLeft = false;  // Reset facing direction
            hills.splice(0, hills.length);
            for (let i = 0; i < 10; i++) {
                hills.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 50,
                    height: 50,
                    color: "brown",
                    resources: 5
                });
            }
            playerSpeed = playerSpeed;
            attackRange = attackRange;
            moneyPerKill = moneyPerKill;
            
            // Clear existing enemies and spawn new ones for the new level
            enemies.splice(0, enemies.length);
            projectiles.splice(0, projectiles.length);
            fireballs.splice(0, fireballs.length);
            poisonBottles.splice(0, poisonBottles.length);
            miniBosses.splice(0, miniBosses.length);
            bossKilled = false;
            
            // Reset timer for new level
            levelTimeRemaining = baseLevelTime;
            levelStartTime = Date.now();
            timerDisplay.textContent = levelTimeRemaining;
            
            spawnEnemies();
            
            gameLoop()
        }

        function showGameOver(reason) {
            gameActive = false;
            spawnEnemiesEnabled = false;
            trackEvent('game_over', { level: level, reason: reason }); // GA Event
            
            // Update final stats
            finalLevelDisplay.textContent = level;
            finalKillsDisplay.textContent = kills;
            finalMoneyDisplay.textContent = money;
            // Submit leaderboard update if logged in (exclude current level time)
            const totalSeconds = cumulativeCompletedLevelSeconds;
            updateUserBest(level, totalSeconds);
            
            // Show game over screen
            gameOverElement.style.display = "flex";
            shopElement.style.display = "none";
            victoryElement.style.display = "none";
            updateUserBarVisibility();
        }

        function resetGame() {
            level = 1;
            kills = 0;
            weaponDamage = 50;
            money = 0;
            player.x = 50;
            player.y = canvas.height - 100;
            maxHearts = 3;  // Reset max hearts when game restarts
            player.hearts = maxHearts;
            player.inventory = [];
            player.facingLeft = false;  // Reset facing direction
            hills.splice(0, hills.length);
            for (let i = 0; i < 10; i++) {
                hills.push({
                    x: Math.random() * (canvas.width - 50),
                    y: Math.random() * (canvas.height - 50),
                    width: 50,
                    height: 50,
                    color: "brown",
                    resources: 5
                });
            }
            enemies.splice(0, enemies.length);
            spawnEnemies();
            projectiles.splice(0, projectiles.length);
            fireballs.splice(0, fireballs.length);
            poisonBottles.splice(0, poisonBottles.length);
            miniBosses.splice(0, miniBosses.length);
            builtBlocks.splice(0, builtBlocks.length);
            enemySpawnInterval = 1000;
            enemiesToKillForLevel = 10;
            playerSpeed = 5;
            attackRange = 50;
            moneyPerKill = 5;
            gameActive = false;  // Don't start automatically
            gameStarted = false;
            shopElement.style.display = "none";
            victoryElement.style.display = "none";
            gameOverElement.style.display = "none";
            welcomeScreen.style.display = "flex";  // Show welcome screen again
            bossKilled = false;
            
            // Reset timer
            baseLevelTime = 70;  // Reset base time when game restarts
            levelTimeRemaining = baseLevelTime;
            levelStartTime = Date.now();
            cumulativeCompletedLevelSeconds = 0;
            
            // Reset attack state
            attackStartTime = 0;
            attackEnded = false;
            attackDuration = 3000;  // Reset attack duration to 3 seconds
            
            levelDisplay.textContent = level;
            killsDisplay.textContent = kills;
            moneyDisplay.textContent = money;
            timerDisplay.textContent = levelTimeRemaining;
            challengeDisplay.textContent = `×”×¨×•×’ ${enemiesToKillForLevel} ××•×™×‘×™× ×›×“×™ ×œ×¢×‘×•×¨ ×©×œ×‘!`;
            
            // Reset individual item prices
            speedPrice = 50;
            rangePrice = 50;
            moneyPrice = 50;
            healthPrice = 100;
            timePrice = 25;
            // Reset current values to starting values
            currentValues = {
                speed: 5,   // Reset to starting speed
                range: 50,  // Reset to starting range
                money: 5,   // Reset to starting money per kill
                health: 3,  // Reset to starting max hearts
                time: 70    // Reset to starting base level time
            };
            updateShopPrices();  // Update shop prices after game reset
            resetSessionPurchases();  // Reset purchase tracking
            // Don't start game loop automatically
        }

        function drawChallenges() {
            ctx.fillStyle = "white";
            ctx.font = "16px Arial";
            ctx.fillText(challengeDisplay.textContent, 10, 100);
        }

        function draw() {
            // Draw level-appropriate background
            drawBackground();

            // Draw player with rotation and horizontal mirroring
            if (playerImage.complete) {
                ctx.save();
                // Move to player center for rotation
                ctx.translate(player.x + player.width/2, player.y + player.height/2);
                // Apply horizontal mirroring if facing left
                if (player.facingLeft) {
                    ctx.scale(-1, 1);
                }
                // Rotate based on player direction
                ctx.rotate(player.rotation * Math.PI / 180);
                // Draw player image centered
                ctx.drawImage(playerImage, -player.width/2, -player.height/2, player.width, player.height);
                ctx.restore();
            } else {
                // Fallback to rectangle if image not loaded
                ctx.fillStyle = player.color;
                ctx.fillRect(player.x, player.y, player.width, player.height);
            }

            hills.forEach(hill => {
                // Draw rock emoji instead of colored rectangle
                ctx.font = "50px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸª¨", hill.x + hill.width/2, hill.y + hill.height - 5);
                ctx.textAlign = "start"; // Reset text alignment
            });

            builtBlocks.forEach(block => {
                // Draw brick emoji instead of colored rectangle
                ctx.font = "30px Arial";
                ctx.textAlign = "center";
                ctx.fillText("ğŸ§±", block.x + block.width/2, block.y + block.height - 5);
                ctx.textAlign = "start"; // Reset text alignment
            });

            enemies.forEach(enemy => {
                if (enemy.isBoss) {
                    // Boss hit flash effect
                    const timeSinceHit = Date.now() - enemy.hitFlash;
                    const shouldFlash = timeSinceHit < 300 && Math.floor(timeSinceHit / 50) % 2 === 0;
                    
                    // Draw boss - use images for specific levels, rectangle for others
                    if (level === 5 && boss1Image.complete && !shouldFlash) {
                        // Draw level 5 boss using image (normal state)
                        ctx.drawImage(boss1Image, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else if (level === 10 && boss2Image.complete && !shouldFlash) {
                        // Draw level 10 boss using image (normal state)
                        ctx.drawImage(boss2Image, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else if (level === 15 && boss3Image.complete && !shouldFlash) {
                        // Draw level 15 boss using image (normal state)
                        ctx.drawImage(boss3Image, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else if (level === 20 && boss4Image.complete && !shouldFlash) {
                        // Draw level 20 boss using image (normal state)
                        ctx.drawImage(boss4Image, enemy.x, enemy.y, enemy.width, enemy.height);
                    } else {
                        // Draw boss as rectangle (flash effect or image not loaded)
                        if (shouldFlash) {
                            ctx.fillStyle = "white";
                        } else {
                            ctx.fillStyle = enemy.color;
                        }
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                    
                    // Draw boss health bar
                    const barWidth = enemy.width;
                    const barHeight = 4;
                    const healthRatio = enemy.lives / enemy.maxLives;
                    
                    // Background (red)
                    ctx.fillStyle = "red";
                    ctx.fillRect(enemy.x, enemy.y - 15, barWidth, barHeight);
                    
                    // Health (green)
                    ctx.fillStyle = "lime";
                    ctx.fillRect(enemy.x, enemy.y - 15, barWidth * healthRatio, barHeight);
                    
                    // Draw protection dome if boss is protected
                    if (Date.now() < enemy.protectionEndTime) {
                        const centerX = enemy.x + enemy.width / 2;
                        const centerY = enemy.y + enemy.height / 2;
                        const domeRadius = enemy.width * 0.8;
                        
                        // Draw dome outline
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.strokeStyle = "cyan";
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        
                        // Draw semi-transparent dome fill
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
                        ctx.fill();
                    }
                } else {
                    // Regular enemy - with hit flash effect for multi-life enemies
                    const timeSinceHit = Date.now() - enemy.hitFlash;
                    const shouldFlash = timeSinceHit < 300 && Math.floor(timeSinceHit / 50) % 2 === 0;
                    
                    if (!shouldFlash) {
                        // Draw regular enemy using images
                        if (enemy.color === "red" && redEnemyImage.complete) {
                            // Draw red enemy using image
                            ctx.drawImage(redEnemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else if (enemy.color === "yellow" && yellowEnemyImage.complete) {
                            // Draw yellow enemy using image
                            ctx.drawImage(yellowEnemyImage, enemy.x, enemy.y, enemy.width, enemy.height);
                        } else {
                            // Fallback to colored rectangle if images not loaded
                            ctx.fillStyle = enemy.color;
                            ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                        }
                    } else {
                        // Flash effect - draw white rectangle
                        ctx.fillStyle = "white";
                        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                    }
                    
                    // Draw health bar for multi-life enemies (level 11+)
                    if (enemy.lives && enemy.maxLives > 1) {
                        const barWidth = enemy.width;
                        const barHeight = 3;  // Smaller than boss health bar
                        const healthRatio = enemy.lives / enemy.maxLives;
                        
                        // Background (red)
                        ctx.fillStyle = "red";
                        ctx.fillRect(enemy.x, enemy.y - 10, barWidth, barHeight);
                        
                        // Health (green)
                        ctx.fillStyle = "lime";
                        ctx.fillRect(enemy.x, enemy.y - 10, barWidth * healthRatio, barHeight);
                    }
                    
                    // Draw protection dome if enemy is protected
                    if (Date.now() < enemy.protectionEndTime) {
                        const centerX = enemy.x + enemy.width / 2;
                        const centerY = enemy.y + enemy.height / 2;
                        const domeRadius = enemy.width * 0.6;  // Smaller than boss dome
                        
                        // Draw dome outline
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.strokeStyle = "lightblue";
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Draw semi-transparent dome fill
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                        ctx.fillStyle = "rgba(173, 216, 230, 0.3)";
                        ctx.fill();
                    }
                }
            });

            projectiles.forEach(projectile => {
                ctx.fillStyle = "black";
                ctx.fillRect(projectile.x, projectile.y, projectile.width || 5, projectile.height || 5);
            });

            fireballs.forEach(fireball => {
                // Draw fireball as large fire emoji (almost boss size)
                ctx.font = "40px Arial";  // Much larger to match the bigger fireball hitbox
                ctx.textAlign = "center";
                ctx.fillText("ğŸ”¥", fireball.x + fireball.width/2, fireball.y + fireball.height - 5);
                ctx.textAlign = "start"; // Reset text alignment
            });

            miniBosses.forEach(miniBoss => {
                // Mini-boss hit flash effect
                const timeSinceHit = Date.now() - miniBoss.hitFlash;
                const shouldFlash = timeSinceHit < 300 && Math.floor(timeSinceHit / 50) % 2 === 0;
                
                // Draw mini-boss - use image when available and not flashing
                if (miniBossImage.complete && !shouldFlash) {
                    // Draw mini-boss using image (normal state)
                    ctx.drawImage(miniBossImage, miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
                } else {
                    // Draw mini-boss as rectangle (flash effect or image not loaded)
                    if (shouldFlash) {
                        ctx.fillStyle = "white";
                    } else {
                        ctx.fillStyle = miniBoss.color;
                    }
                    ctx.fillRect(miniBoss.x, miniBoss.y, miniBoss.width, miniBoss.height);
                }
                
                // Draw mini-boss health bar
                const barWidth = miniBoss.width;
                const barHeight = 3;
                const healthRatio = miniBoss.lives / miniBoss.maxLives;
                
                // Background (red)
                ctx.fillStyle = "red";
                ctx.fillRect(miniBoss.x, miniBoss.y - 10, barWidth, barHeight);
                
                // Health (green)
                ctx.fillStyle = "lime";
                ctx.fillRect(miniBoss.x, miniBoss.y - 10, barWidth * healthRatio, barHeight);
                
                // Draw protection dome if mini-boss is protected
                if (Date.now() < miniBoss.protectionEndTime) {
                    const centerX = miniBoss.x + miniBoss.width / 2;
                    const centerY = miniBoss.y + miniBoss.height / 2;
                    const domeRadius = miniBoss.width * 0.8;
                    
                    // Draw dome outline
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                    ctx.strokeStyle = "cyan";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Draw semi-transparent dome fill
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, domeRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = "rgba(0, 255, 255, 0.2)";
                    ctx.fill();
                }
            });

            poisonBottles.forEach(poison => {
                // Draw poison bottle as poison emoji
                ctx.font = "18px Arial";
                ctx.textAlign = "center";
                ctx.fillText("â˜ ï¸", poison.x + poison.width/2, poison.y + poison.height - 2);
                ctx.textAlign = "start"; // Reset text alignment
            });

            drawChallenges();

            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            levelDisplay.textContent = level;
            killsDisplay.textContent = kills;
            moneyDisplay.textContent = `${money} $`;
            heartsDisplay.textContent = 'â¤ï¸'.repeat(player.hearts);

            // Only show attack circle when actively attacking
            if (keys["d"] && attackStartTime > 0 && !attackEnded) {
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, attackRange, 0, 2 * Math.PI);
                ctx.strokeStyle = "green";
                ctx.stroke();
            }
            
            // Show attack duration bar only when attacking
            if (attackStartTime > 0 && !attackEnded) {
                const attackProgress = (Date.now() - attackStartTime) / attackDuration;
                const barWidth = 100;
                const barHeight = 8;
                const barX = player.x - (barWidth - player.width) / 2;
                const barY = player.y - 25;
                
                // Background
                ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Progress
                ctx.fillStyle = "green";
                ctx.fillRect(barX, barY, barWidth * Math.min(attackProgress, 1), barHeight);
                
                // Border
                ctx.strokeStyle = "white";
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        }

        function gameLoop() {
            if (gameActive) {
                // Update timer
                const timeElapsed = Math.floor((Date.now() - levelStartTime) / 1000);
                levelTimeRemaining = Math.max(0, baseLevelTime - timeElapsed);
                timerDisplay.textContent = levelTimeRemaining;
                
                // Check if time is up
                if (levelTimeRemaining <= 0) {
                    showGameOver("×–××Ÿ × ×’××¨!");
                    return;
                }
                
                movePlayer();
                placeBlock();
                moveEnemies();
                moveProjectiles();
                moveFireballs();
                movePoisonBottles();
                moveMiniBosses();
                attackEnemies();
                draw();

                enemies.forEach(enemy => {
                    if (enemy.color === "red" && checkCollision(player, enemy)) {
                        const damage = getEnemyProjectileDamage();
                        player.hearts -= damage;
                        enemies.splice(enemies.indexOf(enemy), 1);
                        console.log(`Red enemy hit! Damage: ${damage}, Hearts left: ${player.hearts}`);
                        if (player.hearts <= 0) {
                            showGameOver("× ×’××¨×• ×”×—×™×™×!");
                        }
                    }
                });

                // Check level completion
                const isBossLevel = level === 5 || level === 10 || level === 15 || level === 20;
                const levelComplete = isBossLevel ? bossKilled : kills >= enemiesToKillForLevel;
                
                if (levelComplete) {
                    gameActive = false;
                    spawnEnemiesEnabled = false;
                    resetSessionPurchases();  // Reset purchase tracking when opening shop
                    shopElement.style.display = "flex";
                }
                if (player.hearts > 0) {
                    requestAnimationFrame(gameLoop);
                } else {
                    showGameOver("× ×’××¨×• ×”×—×™×™×!");
                }
            }
            else{
                draw();
            }
        }

        // Individual item prices that increase with each purchase
        let speedPrice = 50;
        let rangePrice = 50;
        let moneyPrice = 50;
        let healthPrice = 100;
        let timePrice = 25;

        // Track purchases in current shopping session
        let currentSessionPurchases = {
            speed: 0,
            range: 0,
            money: 0,
            health: 0,
            time: 0
        };

        // Track current total values (not just upgrades purchased)
        let currentValues = {
            speed: 5,   // Current player speed (starts at 5)
            range: 50,  // Current attack range (starts at 50)  
            money: 5,   // Current money per kill (starts at 5)
            health: 3,  // Current max hearts (starts at 3)
            time: 70    // Current base level time (starts at 70)
        };

        // Function to update shop button text with current prices
        function updateShopPrices() {
            buySpeedButton.textContent = `××”×™×¨×•×ª +1 (${speedPrice}$) | ×™×© ×œ×š: ${currentValues.speed}`;
            buyRangeButton.textContent = `×˜×•×•×— +1 (${rangePrice}$) | ×™×© ×œ×š: ${currentValues.range}`;
            buyMoneyButton.textContent = `×›×¡×£ +1 (${moneyPrice}$) | ×™×© ×œ×š: ${currentValues.money}`;
            buyHealthButton.textContent = `×—×™×™× +1 (${healthPrice}$) | ×™×© ×œ×š: ${currentValues.health}`;
            buyTimeButton.textContent = `×–××Ÿ +10 ×©× ×™×•×ª (${timePrice}$) | ×™×© ×œ×š: ${currentValues.time}`;
        }

        // Function to update purchase history display
        function updatePurchaseHistory() {
            const purchases = [];
            if (currentSessionPurchases.speed > 0) {
                purchases.push(`××”×™×¨×•×ª: ${currentSessionPurchases.speed}`);
            }
            if (currentSessionPurchases.range > 0) {
                purchases.push(`×˜×•×•×—: ${currentSessionPurchases.range}`);
            }
            if (currentSessionPurchases.money > 0) {
                purchases.push(`×›×¡×£: ${currentSessionPurchases.money}`);
            }
            if (currentSessionPurchases.health > 0) {
                purchases.push(`×—×™×™×: ${currentSessionPurchases.health}`);
            }
            if (currentSessionPurchases.time > 0) {
                purchases.push(`×–××Ÿ: ${currentSessionPurchases.time}`);
            }

            if (purchases.length > 0) {
                purchaseListDiv.innerHTML = purchases.join('<br>');
                purchaseHistoryDiv.style.display = 'block';
            } else {
                purchaseHistoryDiv.style.display = 'none';
            }
        }

        // Function to reset current session purchases
        function resetSessionPurchases() {
            currentSessionPurchases = {
                speed: 0,
                range: 0,
                money: 0,
                health: 0,
                time: 0
            };
            updatePurchaseHistory();
        }

        buySpeedButton.addEventListener("click", () => {
            if (money >= speedPrice) {
                money -= speedPrice;
                trackEvent('purchase', { item_name: 'speed_upgrade', value: speedPrice, currency: 'USD' }); // GA Event
                speedPrice += 5;  // Increase price for next purchase
                player.speed += 1;
                currentSessionPurchases.speed += 1;  // Track purchase
                currentValues.speed = player.speed;  // Update current value
                moneyDisplay.textContent = `${money} $`;
                playerSpeed = player.speed;
                updateShopPrices();  // Update button text with new price
                updatePurchaseHistory();  // Update purchase display
            }
        });

        buyRangeButton.addEventListener("click", () => {
            if (money >= rangePrice) {
                money -= rangePrice;
                trackEvent('purchase', { item_name: 'range_upgrade', value: rangePrice, currency: 'USD' }); // GA Event
                rangePrice += 5;  // Increase price for next purchase
                attackRange += 10;
                currentSessionPurchases.range += 1;  // Track purchase
                currentValues.range = attackRange;  // Update current value
                moneyDisplay.textContent = `${money} $`;
                attackRange = attackRange;
                updateShopPrices();  // Update button text with new price
                updatePurchaseHistory();  // Update purchase display
            }
        });

        buyMoneyButton.addEventListener("click", () => {
            if (money >= moneyPrice) {
                money -= moneyPrice;
                trackEvent('purchase', { item_name: 'money_per_kill_upgrade', value: moneyPrice, currency: 'USD' }); // GA Event
                moneyPrice += 5;  // Increase price for next purchase
                moneyPerKill += 1;
                currentSessionPurchases.money += 1;  // Track purchase
                currentValues.money = moneyPerKill;  // Update current value
                moneyDisplay.textContent = `${money} $`;
                moneyPerKill = moneyPerKill;
                updateShopPrices();  // Update button text with new price
                updatePurchaseHistory();  // Update purchase display
            }
        });

        buyHealthButton.addEventListener("click", () => {
            if (money >= healthPrice) {
                money -= healthPrice;
                trackEvent('purchase', { item_name: 'health_upgrade', value: healthPrice, currency: 'USD' }); // GA Event
                healthPrice += 5;  // Increase price for next purchase
                maxHearts += 1;  // Increase max hearts permanently
                player.hearts = maxHearts;  // Set current hearts to new max
                currentSessionPurchases.health += 1;  // Track purchase
                currentValues.health = maxHearts;  // Update current value
                moneyDisplay.textContent = `${money} $`;
                heartsDisplay.textContent = 'â¤ï¸'.repeat(player.hearts);
                updateShopPrices();  // Update button text with new price
                updatePurchaseHistory();  // Update purchase display
            }
        });

        buyTimeButton.addEventListener("click", () => {
            if (money >= timePrice) {
                money -= timePrice;
                trackEvent('purchase', { item_name: 'time_upgrade', value: timePrice, currency: 'USD' }); // GA Event
                timePrice += 5;  // Increase price for next purchase
                // Permanently increase base level time for all future levels
                baseLevelTime += 10;
                currentSessionPurchases.time += 1;  // Track purchase
                currentValues.time = baseLevelTime;  // Update current value
                moneyDisplay.textContent = `${money} $`;
                updateShopPrices();  // Update button text with new price
                updatePurchaseHistory();  // Update purchase display
            }
        });

        shopContinueButton.addEventListener("click", () => {
            if (!gameActive) {
                resetSessionPurchases();  // Reset purchase tracking
                spawnEnemiesEnabled = true;
                advanceLevel();
            }
        });

        playAgainButton.addEventListener("click", () => {
            victoryElement.style.display = "none";
            spawnEnemiesEnabled = true;
            resetGame();
        });

        restartGameButton.addEventListener("click", () => {
            gameOverElement.style.display = "none";
            spawnEnemiesEnabled = true;
            resetGame();
        });

        startGameButton.addEventListener("click", () => {
            welcomeScreen.style.display = "none";
            gameStarted = true;
            gameActive = true;
            spawnEnemiesEnabled = true;
            gameSessionStart = Date.now();
            updateShopPrices();  // Set initial shop prices
            trackEvent('game_start'); // GA Event
            setInterval(spawnNewEnemy, enemySpawnInterval);
            updateUserBarVisibility();
            gameLoop();
        });
    </script>
</body>
</html>
